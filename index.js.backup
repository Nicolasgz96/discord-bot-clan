require('dotenv').config();

// --- FFmpeg fallback (debe estar antes de cualquier voice require) ---
// prism-media busca FFmpeg en el PATH del sistema, no en FFMPEG_PATH
try {
  const ffmpeg = require('@ffmpeg-installer/ffmpeg');
  const path = require('path');
  const ffmpegDir = path.dirname(ffmpeg.path);
  
  // Agregar el directorio de FFmpeg al PATH del proceso (Windows usa ; como separador)
  const pathSeparator = process.platform === 'win32' ? ';' : ':';
  if (!process.env.PATH.includes(ffmpegDir)) {
    process.env.PATH = `${ffmpegDir}${pathSeparator}${process.env.PATH}`;
  }
  
  // Tambi√©n configurar FFMPEG_PATH por si acaso
  process.env.FFMPEG_PATH = ffmpeg.path;
  
  console.log(`[FFmpeg] Ruta configurada: ${ffmpeg.path}`);
  console.log(`[FFmpeg] Directorio agregado al PATH: ${ffmpegDir}`);
} catch (error) {
  console.warn('[FFmpeg] No se pudo cargar @ffmpeg-installer/ffmpeg. Usar√© el del sistema si existe.');
  console.warn(`[FFmpeg] Error: ${error.message}`);
}

const { Client, GatewayIntentBits, Events, PermissionFlagsBits, ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder, MessageFlags, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, ComponentType } = require('discord.js');
const config = require('./config.json');
const { createWelcomeCard } = require('./utils/welcomeCard');
const { validateConfig } = require('./utils/configValidator');
const { connectToVoiceChannel, disconnectFromVoiceChannel, speakText, isConnected, isUserInBotVoiceChannel, getVoiceChannelInfo, setVoiceChannelTextChannel } = require('./utils/voiceManager');

// DEMON HUNTER - Samurai Theme Config
const COLORS = require('./src/config/colors');
const EMOJIS = require('./src/config/emojis');
const MESSAGES = require('./src/config/messages');
const CONSTANTS = require('./src/config/constants');
const dataManager = require('./utils/dataManager');
const musicHandlers = require('./commands/handlers/musicHandlers');

// Validar configuraci√≥n al iniciar
try {
  validateConfig(config);
  console.log('‚úì Configuraci√≥n validada exitosamente');
} catch (error) {
  console.error('‚ùå Validaci√≥n de configuraci√≥n fall√≥:', error.message);
  console.error('Por favor corrige tu config.json e intenta de nuevo.');
  process.exit(1);
}

// Rate limiting (now using dataManager for persistence)
const COOLDOWN_SECONDS = CONSTANTS.COOLDOWNS.COMMAND_DEFAULT;

// Almacenamiento temporal de mensajes borrados (para deshacer)
const deletedMessagesCache = new Map();
const UNDO_TIMEOUT_MINUTES = CONSTANTS.MODERATION.DELETE.UNDO_TIMEOUT_MINUTES;

// Channel locks para prevenir operaciones concurrentes de borrado en el mismo canal
const channelLocks = new Set();

// ‚úÖ FIX BUG #3: Cache de usernames para reducir llamadas a Discord API
// { userId: { username: string, timestamp: number } }
const usernameCache = new Map();
const USERNAME_CACHE_TTL = 60 * 60 * 1000; // 1 hora en milisegundos

// Rastreo de √∫ltimos usuarios que hablaron en voz (para no repetir nombres)
// { guildId: { lastUserId: string, lastTimestamp: number } }
const lastVoiceSpeakers = new Map();
const VOICE_NAME_REPEAT_SECONDS = CONSTANTS.VOICE.VOICE_NAME_REPEAT_SECONDS; // Segundos antes de repetir el nombre del mismo usuario

// Sistema de rastreo de tiempo en voz para honor
// { userId_guildId: { joinedAt: timestamp, lastHonorGrant: timestamp } }
const voiceTimeTracking = new Map();

// ‚úÖ FIX BUG #2: Limpieza autom√°tica de tracking hu√©rfanos (cada 1 hora)
setInterval(() => {
  const now = Date.now();
  const oneHourAgo = now - (60 * 60 * 1000);
  let cleaned = 0;

  for (const [key, data] of voiceTimeTracking.entries()) {
    // Si el tracking es de hace m√°s de 1 hora, eliminarlo (probablemente hu√©rfano)
    if (data.joinedAt < oneHourAgo) {
      voiceTimeTracking.delete(key);
      cleaned++;
    }
  }

  if (cleaned > 0) {
    console.log(`üßπ [Cleanup] Eliminados ${cleaned} tracking hu√©rfanos de voz`);
  }
  console.log(`üìä [Cleanup] voiceTimeTracking entries actuales: ${voiceTimeTracking.size}`);
}, 60 * 60 * 1000); // Cada 1 hora

// ‚úÖ FIX BUG #3: Limpieza autom√°tica de cache de usernames (cada 1 hora)
setInterval(() => {
  const now = Date.now();
  let cleaned = 0;

  for (const [userId, data] of usernameCache.entries()) {
    // Si la entrada del cache tiene m√°s de 1 hora, eliminarla
    if ((now - data.timestamp) > USERNAME_CACHE_TTL) {
      usernameCache.delete(userId);
      cleaned++;
    }
  }

  if (cleaned > 0) {
    console.log(`üßπ [Cleanup] Eliminadas ${cleaned} entradas expiradas del cache de usernames`);
  }
  console.log(`üìä [Cleanup] usernameCache entries actuales: ${usernameCache.size}`);
}, 60 * 60 * 1000); // Cada 1 hora

// Create Discord client with necessary intents
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates,
  ],
});

// Evento cuando el bot est√° listo
client.once(Events.ClientReady, async (c) => {
  console.log(`\n${EMOJIS.DRAGON}${EMOJIS.KATANA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${EMOJIS.KATANA}${EMOJIS.DRAGON}`);
  console.log(`${EMOJIS.CASTLE} DEMON HUNTER BOT - SISTEMA SAMURAI`);
  console.log(`${EMOJIS.TORII}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${EMOJIS.TORII}\n`);
  console.log(`${EMOJIS.SUCCESS} Bot en l√≠nea como ${c.user.tag}`);
  console.log(`${EMOJIS.CASTLE} Sirviendo ${c.guilds.cache.size} dojos (servidores)`);
  console.log(`${EMOJIS.SAKURA} Funci√≥n de bienvenida: ${config.welcome.enabled ? 'Activada' : 'Desactivada'}`);
  if (config.autoRole && config.autoRole.enabled) {
    if (config.autoRole.roleId) {
      console.log(`${EMOJIS.RONIN} Asignaci√≥n autom√°tica de rol: Activada (Rol ID: ${config.autoRole.roleId})`);
    } else {
      console.log(`${EMOJIS.WARNING} Asignaci√≥n autom√°tica de rol: Activada pero sin rol configurado (configura roleId en config.json)`);
    }
  } else {
    console.log(`${EMOJIS.INFO} Asignaci√≥n autom√°tica de rol: Desactivada`);
  }

  // Initialize data manager (JSON persistence)
  try {
    await dataManager.init();
    console.log(`${EMOJIS.SUCCESS} Sistema de persistencia de datos activado`);
  } catch (error) {
    console.error(`${EMOJIS.ERROR} Error inicializando sistema de datos:`, error);
    console.error(`${EMOJIS.WARNING} El bot continuar√°, pero los datos no se guardar√°n`);
  }

  console.log(`\n${EMOJIS.FLAG} C√≥digo Bushido activado. El dojo est√° listo.\n`);
});

// Evento cuando un nuevo miembro se une
client.on(Events.GuildMemberAdd, async (member) => {
  // ========== ASIGNACI√ìN AUTOM√ÅTICA DE ROL ==========
  if (config.autoRole && config.autoRole.enabled && config.autoRole.roleId) {
    try {
      const role = member.guild.roles.cache.get(config.autoRole.roleId);
      
      if (!role) {
        console.error(`‚ùå Rol autom√°tico no encontrado: ${config.autoRole.roleId} en ${member.guild.name}`);
        console.error(`üí° Verifica que el ID del rol sea correcto y que el bot pueda ver el rol`);
        return; // Salir temprano si no hay rol
      }

      const botMember = member.guild.members.me;
      
      // Verificar que el bot tiene permisos para asignar roles
      if (!botMember.permissions.has(PermissionFlagsBits.ManageRoles)) {
        console.error(`‚ùå El bot no tiene el permiso "Administrar Roles" en ${member.guild.name}`);
        console.error(`üí° Soluci√≥n: Ve a Configuraci√≥n del Servidor ‚Üí Roles ‚Üí Rol del Bot ‚Üí Activa "Administrar Roles"`);
        return;
      }

      // Verificar que el rol del bot est√© por encima del rol a asignar
      if (botMember.roles.highest.position <= role.position) {
        console.error(`‚ùå El rol del bot (${botMember.roles.highest.name}) debe estar por encima del rol "${role.name}" para poder asignarlo`);
        console.error(`üí° Soluci√≥n: Arrastra el rol del bot por encima del rol "${role.name}" en Configuraci√≥n del Servidor ‚Üí Roles`);
        return;
      }

      // Verificar que el rol no est√© gestionado por una integraci√≥n (como MEE6, Dyno, etc.)
      if (role.managed) {
        console.error(`‚ùå El rol "${role.name}" est√° gestionado por una integraci√≥n y no puede ser asignado autom√°ticamente`);
        console.error(`üí° Soluci√≥n: Usa un rol que no est√© gestionado por otro bot o integraci√≥n`);
        return;
      }

      // Intentar asignar el rol
      await member.roles.add(role, 'Asignaci√≥n autom√°tica de rol al unirse al servidor');
      console.log(`‚úì Rol "${role.name}" asignado autom√°ticamente a ${member.user.tag} en ${member.guild.name}`);
      
    } catch (error) {
      console.error(`‚ùå Error asignando rol autom√°tico a ${member.user.tag} en ${member.guild.name}:`, error.message);
      
      // Mensajes de error m√°s espec√≠ficos
      if (error.code === 50013) {
        console.error(`üí° El bot no tiene permisos suficientes. Verifica que tenga "Administrar Roles" y que su rol est√© por encima del rol a asignar.`);
      } else if (error.code === 10011) {
        console.error(`üí° El rol no existe o el bot no puede verlo. Verifica el ID del rol en config.json`);
      } else {
        console.error(`üí° Error desconocido. Verifica los permisos del bot y la configuraci√≥n del rol.`);
      }
    }
  }
  // ========== FIN ASIGNACI√ìN AUTOM√ÅTICA DE ROL ==========

  // Verificar si la funci√≥n de bienvenida est√° activada
  if (!config.welcome.enabled) return;

  try {
    // Obtener el canal de bienvenida
    const channel = member.guild.channels.cache.get(config.welcome.channelId);

    if (!channel) {
      console.error(`‚ùå Canal de bienvenida no encontrado: ${config.welcome.channelId}`);
      return;
    }

    // Crear la tarjeta de bienvenida
    const attachment = await createWelcomeCard(member);

    // Enviar el mensaje de bienvenida con l√≥gica de reintento
    const displayName = member.displayName || member.user.username;
    await sendWithRetry(channel, {
      content: `${EMOJIS.CASTLE} ${MESSAGES.WELCOME.NEW_MEMBER(displayName)} ${EMOJIS.DRAGON}`,
      files: [attachment],
    });

    console.log(`${EMOJIS.SUCCESS} Tarjeta de bienvenida enviada para ${member.user.tag}`);
  } catch (error) {
    console.error(`‚ùå Error al enviar mensaje de bienvenida para ${member.user.tag}:`, error.message);
  }
});

// Evento cuando el estado de voz de alguien cambia
// Se usa para desconectar el bot autom√°ticamente si se queda solo
// Y para rastrear tiempo en voz (honor pasivo)
client.on(Events.VoiceStateUpdate, async (oldState, newState) => {
  try {
    const guildId = oldState.guild.id;
    const userId = oldState.member.id;
    const trackingKey = `${userId}_${guildId}`;

    // ========== SISTEMA DE HONOR PASIVO: VOZ ==========
    // Rastrear cuando usuarios se unen/salen de canales de voz

    // Usuario se uni√≥ a un canal de voz
    if (!oldState.channelId && newState.channelId) {
      // Usuario entr√≥ a voz
      voiceTimeTracking.set(trackingKey, {
        joinedAt: Date.now(),
        lastHonorGrant: Date.now()
      });
      // console.log(`[Voice] ${oldState.member.user.tag} entr√≥ a voz`);
    }

    // Usuario sali√≥ de un canal de voz
    else if (oldState.channelId && !newState.channelId) {
      // Usuario sali√≥ de voz - otorgar honor por tiempo total
      const tracking = voiceTimeTracking.get(trackingKey);

      if (tracking) {
        // ‚úÖ FIX BUG #1: Calcular minutos DESDE el √∫ltimo grant para evitar duplicaci√≥n
        const minutesSinceLastGrant = Math.floor((Date.now() - tracking.lastHonorGrant) / 60000);
        const totalMinutes = Math.floor((Date.now() - tracking.joinedAt) / 60000);

        if (minutesSinceLastGrant > 0) {
          // Otorgar honor y koku solo por los minutos RESTANTES (no por el total)
          const honorToGrant = minutesSinceLastGrant * CONSTANTS.HONOR.PER_VOICE_MINUTE;
          const kokuToGrant = Math.floor(minutesSinceLastGrant * CONSTANTS.ECONOMY.PER_VOICE_MINUTE);

          try {
            const userData = dataManager.addHonor(userId, guildId, honorToGrant);
            userData.koku = (userData.koku || 0) + kokuToGrant;

            // Actualizar estad√≠sticas de voz (usar tiempo TOTAL, no solo restante)
            if (userData.stats) {
              userData.stats.voiceMinutes = (userData.stats.voiceMinutes || 0) + totalMinutes;
            }

            // Actualizar honor total del clan si el usuario pertenece a uno
            if (userData.clanId) {
              dataManager.updateClanStats(userData.clanId);
            }

            // Marcar datos como modificados
            dataManager.dataModified.users = true;

            console.log(`${EMOJIS.VOICE} ${oldState.member.user.tag} gan√≥ ${honorToGrant} honor + ${kokuToGrant} koku por ${minutesSinceLastGrant} minutos restantes en voz (total: ${totalMinutes} min)`);
          } catch (error) {
            console.error('Error otorgando honor/koku por voz:', error.message);
          }
        }

        voiceTimeTracking.delete(trackingKey);
      }
    }

    // Usuario cambi√≥ de canal (se mantiene en voz)
    else if (oldState.channelId && newState.channelId && oldState.channelId !== newState.channelId) {
      // Solo actualizar el timestamp de cambio, no resetear el tiempo total
      // El tracking contin√∫a desde el joinedAt original
      // console.log(`[Voice] ${oldState.member.user.tag} cambi√≥ de canal de voz`);
    }

    // ========== OTORGAR HONOR CADA 10 MINUTOS MIENTRAS EST√Å EN VOZ ==========
    // Verificar si el usuario lleva 10+ minutos en voz
    const tracking = voiceTimeTracking.get(trackingKey);
    if (tracking && newState.channelId) {
      const minutesSinceLastGrant = Math.floor((Date.now() - tracking.lastHonorGrant) / 60000);

      // ‚úÖ FIX BUG #5: Cada 10 minutos, otorgar solo 10 honor (koku se calcula al salir)
      if (minutesSinceLastGrant >= 10) {
        try {
          const userData = dataManager.addHonor(userId, guildId, CONSTANTS.HONOR.PER_VOICE_10MIN_BONUS);
          // Koku se calcula al salir (0.5 koku/min) para evitar duplicaci√≥n
          tracking.lastHonorGrant = Date.now();

          // Actualizar honor total del clan si el usuario pertenece a uno
          if (userData.clanId) {
            dataManager.updateClanStats(userData.clanId);
          }

          // Marcar datos como modificados
          dataManager.dataModified.users = true;

          console.log(`${EMOJIS.HONOR} ${oldState.member.user.tag} gan√≥ 10 honor por 10 minutos en voz activa (koku se calcula al salir)`);
        } catch (error) {
          console.error('Error otorgando honor/koku por voz activa:', error.message);
        }
      }
    }
    // ========== FIN SISTEMA DE HONOR PASIVO: VOZ ==========

    // ========== DESCONEXI√ìN AUTOM√ÅTICA DEL BOT ==========
    // Solo procesar si el bot est√° conectado en este servidor
    if (!isConnected(guildId)) return;

    const voiceChannelInfo = getVoiceChannelInfo(guildId);
    if (!voiceChannelInfo) return;

    const botVoiceChannelId = voiceChannelInfo.channelId;

    // Obtener el canal de voz donde est√° el bot
    const botVoiceChannel = oldState.guild.channels.cache.get(botVoiceChannelId);
    if (!botVoiceChannel) return;

    // Contar usuarios humanos (no bots) en el canal
    const humanMembers = botVoiceChannel.members.filter(member => !member.user.bot);

    // Si no hay usuarios humanos, desconectar el bot
    if (humanMembers.size === 0) {
      console.log(`üîá Canal de voz vac√≠o en ${oldState.guild.name}, desconectando bot...`);
      disconnectFromVoiceChannel(guildId);
      // Limpiar registro de √∫ltimos hablantes
      lastVoiceSpeakers.delete(guildId);

      // Opcional: enviar mensaje en el √∫ltimo canal donde se us√≥ un comando
      // (esto requerir√≠a guardar el canal, as√≠ que lo omitimos por ahora)
    }
  } catch (error) {
    console.error('Error en VoiceStateUpdate:', error);
  }
});

// Funci√≥n auxiliar para enviar mensajes con l√≥gica de reintento
async function sendWithRetry(channel, options, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await channel.send(options);
    } catch (error) {
      if (attempt === maxRetries) throw error;

      const delay = Math.pow(2, attempt - 1) * 1000;
      console.warn(`Env√≠o fall√≥ (intento ${attempt}/${maxRetries}), reintentando en ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Funci√≥n auxiliar para obtener el emoji de un rango
function getRankEmoji(rank) {
  switch (rank) {
    case 'Ronin': return EMOJIS.RONIN;
    case 'Samurai': return EMOJIS.SAMURAI;
    case 'Daimyo': return EMOJIS.DAIMYO;
    case 'Shogun': return EMOJIS.SHOGUN;
    default: return EMOJIS.RONIN;
  }
}

/**
 * ‚úÖ FIX BUG #3: Fetch username con cache para reducir API calls
 * @param {string} userId - ID del usuario de Discord
 * @returns {Promise<string>} - Username del usuario
 */
async function fetchUsername(userId) {
  // Verificar si est√° en cache y no ha expirado
  const cached = usernameCache.get(userId);
  if (cached && (Date.now() - cached.timestamp) < USERNAME_CACHE_TTL) {
    return cached.username;
  }

  // Si no est√° en cache o expir√≥, hacer fetch
  try {
    const discordUser = await client.users.fetch(userId);
    const username = discordUser.username;

    // Guardar en cache
    usernameCache.set(userId, {
      username: username,
      timestamp: Date.now()
    });

    return username;
  } catch (error) {
    // Si falla el fetch, devolver ID truncado
    return `Usuario ${userId.slice(0, 6)}`;
  }
}

/**
 * ‚úÖ FIX BUG #3: Fetch m√∫ltiples usernames en paralelo
 * @param {Array<string>} userIds - Array de IDs de usuarios
 * @returns {Promise<Map<string, string>>} - Map de userId -> username
 */
async function fetchUsernamesBatch(userIds) {
  const promises = userIds.map(userId =>
    fetchUsername(userId).then(username => ({ userId, username }))
  );

  const results = await Promise.all(promises);

  const usernameMap = new Map();
  results.forEach(({ userId, username }) => {
    usernameMap.set(userId, username);
  });

  return usernameMap;
}

/**
 * Obtener displayName del servidor (nombre modificado en el canal)
 * @param {Guild} guild - Servidor de Discord
 * @param {string} userId - ID del usuario
 * @returns {Promise<string>} - DisplayName del usuario en el servidor
 */
async function fetchDisplayName(guild, userId) {
  try {
    // Intentar obtener el miembro del servidor
    let member = guild.members.cache.get(userId);
    
    // Si no est√° en cache, hacer fetch
    if (!member) {
      member = await guild.members.fetch(userId);
    }
    
    // Usar displayName (nombre modificado) o username como fallback
    return member.displayName || member.user.username;
  } catch (error) {
    // Si falla, intentar obtener username como fallback
    try {
      const user = await client.users.fetch(userId);
      return user.username;
    } catch (err) {
      return `Usuario ${userId.slice(0, 6)}`;
    }
  }
}

/**
 * Obtener m√∫ltiples displayNames del servidor en paralelo
 * @param {Guild} guild - Servidor de Discord
 * @param {Array<string>} userIds - Array de IDs de usuarios
 * @returns {Promise<Map<string, string>>} - Map de userId -> displayName
 */
async function fetchDisplayNamesBatch(guild, userIds) {
  const promises = userIds.map(userId =>
    fetchDisplayName(guild, userId).then(displayName => ({ userId, displayName }))
  );

  const results = await Promise.all(promises);

  const displayNameMap = new Map();
  results.forEach(({ userId, displayName }) => {
    displayNameMap.set(userId, displayName);
  });

  return displayNameMap;
}

// Comando de mensaje para probar tarjetas de bienvenida
client.on(Events.MessageCreate, async (message) => {
  // Ignorar mensajes de bots para prevenir bucles infinitos
  if (message.author.bot) return;

  // ========== SISTEMA DE HONOR PASIVO: MENSAJES ==========
  // Ganar honor por enviar mensajes (con cooldown de 1 minuto)
  if (message.guild && message.author && !message.content.startsWith('!') && !message.content.startsWith('/')) {
    try {
      const userId = message.author.id;
      const guildId = message.guild.id;

      // Verificar cooldown de honor por mensajes (1 minuto)
      if (!dataManager.hasCooldown(userId, 'honor_message')) {
        // Ganar honor y koku por mensaje
        const userData = dataManager.addHonor(userId, guildId, CONSTANTS.HONOR.PER_MESSAGE);
        userData.koku = (userData.koku || 0) + CONSTANTS.ECONOMY.PER_MESSAGE;

        // Incrementar contador de mensajes
        if (userData.stats) {
          userData.stats.messagesCount = (userData.stats.messagesCount || 0) + 1;
        }

        // Actualizar honor total del clan si el usuario pertenece a uno
        if (userData.clanId) {
          dataManager.updateClanStats(userData.clanId);
        }

        // Marcar datos como modificados
        dataManager.dataModified.users = true;

        // Establecer cooldown de 1 minuto
        dataManager.setCooldown(userId, 'honor_message', CONSTANTS.COOLDOWNS.HONOR_MESSAGE);

        // Log silencioso (no spam en consola)
        // console.log(`[Honor] ${message.author.tag} gan√≥ 5 honor + 2 koku por mensaje (Total: ${userData.honor} honor, ${userData.koku} koku)`);
      }
    } catch (error) {
      // Fallos silenciosos para no interrumpir el flujo de mensajes
      console.error('Error otorgando honor por mensaje:', error.message);
    }
  }
  // ========== FIN SISTEMA DE HONOR PASIVO ==========

  // ========== LECTURA AUTOM√ÅTICA DE MENSAJES EN VOZ ==========
  // Si el bot est√° conectado a voz y el usuario est√° en el mismo canal,
  // leer autom√°ticamente el mensaje (excepto comandos)
  if (message.guild && !message.content.startsWith('!') && !message.content.startsWith('/')) {
    try {
      const guildId = message.guild.id;

      // Verificar si el bot est√° conectado a voz en este servidor
      if (isConnected(guildId)) {
        // Obtener informaci√≥n del canal de voz del bot
        const voiceInfo = getVoiceChannelInfo(guildId);
        if (!voiceInfo) return;

        // Verificar que el mensaje viene del canal de texto asociado al canal de voz
        if (voiceInfo.textChannelId && message.channel.id !== voiceInfo.textChannelId) {
          return; // Ignorar mensajes de otros canales
        }

        // Verificar si el autor del mensaje est√° en el canal de voz del bot
        const member = message.guild.members.cache.get(message.author.id);

        if (member && isUserInBotVoiceChannel(member)) {
          const userId = message.author.id;
          const userName = member.displayName || message.author.username;
          const now = Date.now();
          
          // Obtener informaci√≥n del √∫ltimo hablante en este servidor
          const lastSpeaker = lastVoiceSpeakers.get(guildId);
          
          // Filtrar TODOS los enlaces/URLs - NO leer mensajes con enlaces
          const messageContent = message.content;
          
          // Detectar cualquier tipo de URL o enlace (patrones m√°s completos)
          const urlPatterns = [
            /https?:\/\/[^\s]+/gi,                    // http:// o https://
            /www\.[^\s]+/gi,                          // www.ejemplo.com
            /discord\.gg\/[^\s]+/gi,                  // discord.gg/invite
            /discord\.com\/[^\s]+/gi,                 // discord.com/gifts, discord.com/invite
            /discordapp\.com\/[^\s]+/gi,              // discordapp.com
            /[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.[a-zA-Z]{2,}\/[^\s]*/gi, // dominio.com/ruta
            /[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.[a-zA-Z]{2,}[^\s]*/gi,   // dominio.com (sin /)
          ];
          
          // Verificar si el mensaje contiene alg√∫n enlace
          let hasLink = false;
          for (const pattern of urlPatterns) {
            // Resetear el lastIndex del regex para evitar problemas
            pattern.lastIndex = 0;
            if (pattern.test(messageContent)) {
              hasLink = true;
              break;
            }
          }
          
          // Si el mensaje contiene cualquier enlace, ignorarlo completamente
          if (hasLink) {
            console.log(`üîá Mensaje ignorado (contiene enlace): ${messageContent.substring(0, 50)}...`);
            return; // No leer mensajes con enlaces
          }
          
          // Usar el contenido original (ya verificado que no tiene enlaces)
          const filteredContent = messageContent;
          
          // Decidir si decir el nombre o no
          let shouldSayName = false;
          let messageToSpeak = filteredContent;
          
          if (!lastSpeaker) {
            // Primera vez que alguien habla en este servidor
            shouldSayName = true;
          } else if (lastSpeaker.lastUserId !== userId) {
            // Cambi√≥ el usuario, decir el nombre
            shouldSayName = true;
          } else if (now - lastSpeaker.lastTimestamp > VOICE_NAME_REPEAT_SECONDS * 1000) {
            // Mismo usuario pero pasaron m√°s de 20 segundos, decir el nombre de nuevo
            shouldSayName = true;
          }
          // Si no se cumple ninguna condici√≥n, no decir el nombre (mismo usuario, menos de 20 segundos)
          
          if (shouldSayName) {
            messageToSpeak = `${userName} dice: ${filteredContent}`;
          }
          
          // Actualizar registro del √∫ltimo hablante
          lastVoiceSpeakers.set(guildId, {
            lastUserId: userId,
            lastTimestamp: now
          });

          // Verificar que la conexi√≥n est√© lista antes de intentar hablar
          // (isConnected ya verifica si existe, pero speakText tambi√©n lo verifica internamente)

          // Leer el mensaje en voz
          await speakText(guildId, messageToSpeak, 'es');
          console.log(`üîä Lectura autom√°tica: ${userName} en ${message.guild.name}${shouldSayName ? ' (con nombre)' : ' (sin nombre)'}`);
        }
      }
    } catch (error) {
      // No interrumpir el procesamiento de comandos si falla la lectura
      console.error('Error en lectura autom√°tica de voz:', error);
      // Si el error es de conexi√≥n, intentar limpiar
      if (error.message && (error.message.includes('No hay conexi√≥n') || error.message.includes('conexi√≥n'))) {
        const guildId = message.guild?.id;
        if (guildId) {
          console.log(`üîÑ Limpiando conexi√≥n de voz para ${guildId} debido a error`);
          disconnectFromVoiceChannel(guildId);
          lastVoiceSpeakers.delete(guildId);
        }
      }
    }
  }
  // ========== FIN LECTURA AUTOM√ÅTICA ==========

  // Comando de prueba de tarjeta de bienvenida
  if (message.content.toLowerCase() === '!testwelcome' || message.content.toLowerCase() === '!bienvenida') {
    const userId = message.author.id;

    // Verificar cooldown (ahora persistente)
    if (dataManager.hasCooldown(userId, 'testwelcome')) {
      const timeLeft = dataManager.getCooldownTime(userId, 'testwelcome');
      return message.reply(MESSAGES.ERRORS.COOLDOWN(timeLeft));
    }

    // Establecer cooldown (se guarda en JSON)
    dataManager.setCooldown(userId, 'testwelcome', COOLDOWN_SECONDS);

    try {
      // Obtener el miembro del servidor
      const member = message.guild.members.cache.get(message.author.id);

      if (!member) {
        await message.reply(MESSAGES.ERRORS.INVALID_USER);
        return;
      }

      // Crear la tarjeta de bienvenida
      const attachment = await createWelcomeCard(member);

      // Enviar la tarjeta de bienvenida de prueba con l√≥gica de reintento
      await sendWithRetry(message.channel, {
        content: `${EMOJIS.SAKURA} ${message.author}, aqu√≠ est√° la vista previa de tu tarjeta de bienvenida samurai:`,
        files: [attachment],
      });

      console.log(`${EMOJIS.SUCCESS} Tarjeta de bienvenida de prueba enviada para ${message.author.tag}`);
    } catch (error) {
      console.error(`${EMOJIS.ERROR} Error creando tarjeta de bienvenida de prueba:`, error);
      await message.reply(`${EMOJIS.ERROR} Lo siento, encontr√© un error creando tu tarjeta de bienvenida. Por favor intenta de nuevo m√°s tarde o contacta al maestro del dojo.`);
    }
  }

  // Comando de ayuda
  if (message.content.toLowerCase() === '!help' || message.content.toLowerCase() === '!ayuda' || message.content.toLowerCase() === '!dojo') {
    try {
      // Obtener nombres de canales si est√°n configurados
      const commandsChannel = config.commandsChannel && config.commandsChannel.enabled && config.commandsChannel.channelId
        ? message.guild.channels.cache.get(config.commandsChannel.channelId)
        : null;
      const shopChannel = config.shopChannel && config.shopChannel.enabled && config.shopChannel.channelId
        ? message.guild.channels.cache.get(config.shopChannel.channelId)
        : null;
      const combatChannel = config.combatChannel && config.combatChannel.enabled && config.combatChannel.channelId
        ? message.guild.channels.cache.get(config.combatChannel.channelId)
        : null;

      const commandsChannelName = commandsChannel ? `**${commandsChannel.name}**` : 'Cualquier canal';
      const shopChannelName = shopChannel ? `**${shopChannel.name}**` : 'Cualquier canal';
      const combatChannelName = combatChannel ? `**${combatChannel.name}**` : 'Cualquier canal';

      const embed = new EmbedBuilder()
        .setColor(COLORS.PRIMARY)
        .setTitle(`${EMOJIS.TORII} Comandos del Dojo - Demon Hunter`)
        .setDescription(`Bienvenido al manual del guerrero, ${message.member?.displayName || message.author.username}. Aqu√≠ encontrar√°s todos los comandos disponibles.\n\n${EMOJIS.KATANA} **Tip:** Escribe \`/\` en Discord para ver todos los comandos con autocompletar!`)
        .addFields(
          // ========== BIENVENIDA Y AYUDA ==========
          {
            name: `${EMOJIS.TORII} __BIENVENIDA Y AYUDA__`,
            value: 'üé® `!testwelcome` / `!bienvenida` - Vista previa de tarjeta de bienvenida\n‚ùì `!help` / `!ayuda` / `!dojo` - Muestra este mensaje\nüìç *Cualquier canal*',
            inline: false
          },
          // ========== MODERACI√ìN ==========
          {
            name: `${EMOJIS.KATANA} __MODERACI√ìN__`,
            value: 'üóëÔ∏è `!borrarmsg` - Elimina mensajes de un usuario\nüîÑ `!deshacerborrado` - Restaura mensajes eliminados\n*Req: Administrar Mensajes*\nüìç *Cualquier canal*',
            inline: false
          },
          // ========== VOZ / TTS ==========
          {
            name: `${EMOJIS.VOICE} __VOZ / TTS__`,
            value: 'üîó `!join` - Bot se une a voz y lee mensajes\nüîä `!hablar <texto>` - Text-to-speech en espa√±ol\nüëã `!salir` - Desconecta el bot de voz\nüìç *Cualquier canal*',
            inline: false
          },
          // ========== HONOR Y RANGOS ==========
          {
            name: `${EMOJIS.HONOR} __HONOR Y RANGOS__`,
            value: `‚≠ê \`!honor [@usuario]\` - Ver honor y progreso de rango\n‚öîÔ∏è \`!rango\` - Info del sistema de rangos\nüèÜ \`!top\` - Ranking de honor (top 10)\nüìç *${commandsChannelName}*`,
            inline: false
          },
          // ========== ECONOM√çA ==========
          {
            name: `${EMOJIS.KOKU} __ECONOM√çA__`,
            value: `üìÖ \`!daily\` - Recompensa diaria de koku\nüí∞ \`!balance\` / \`!bal\` - Ver tu koku, honor y racha\nüí∏ \`!pay\` / \`!pagar\` - Transferir koku a otro usuario\nüìä \`!leaderboard\` / \`!lb\` - Rankings interactivos del dojo\nüìç *${commandsChannelName}*`,
            inline: false
          },
          // ========== CLANES ==========
          {
            name: `${EMOJIS.CLAN} __CLANES__`,
            value: `üèØ Usa \`/clan\` para gestionar clanes:\n\`crear\`, \`info\`, \`unirse\`, \`salir\`, \`miembros\`, \`top\`, \`invitar\`, \`expulsar\`\nüìç *${commandsChannelName}*`,
            inline: false
          },
          // ========== TIENDA ==========
          {
            name: `${EMOJIS.SHOP} __TIENDA__`,
            value: `üè™ \`/tienda ver\` - Ver productos disponibles\nüõí \`/tienda comprar\` - Comprar un item\nüì¶ \`/tienda inventario\` - Ver tu inventario\nüìç *${shopChannelName}*`,
            inline: false
          },
          // ========== COMBATE Y JUEGOS ==========
          {
            name: `${EMOJIS.DUEL} __COMBATE Y JUEGOS__`,
            value: `‚öîÔ∏è \`!duelo @usuario [apuesta]\` - Desaf√≠a a un duelo de honor\nüìú \`!sabiduria\` - Citas de maestros samurai\nüé¥ \`!fortuna\` - Omikuji (fortuna diaria)\nüë§ \`!perfil [@usuario]\` - Ver perfil completo de guerrero\nüìç *${combatChannelName}*`,
            inline: false
          },
          // ========== UTILIDADES ==========
          {
            name: `${EMOJIS.TRANSLATION} __UTILIDADES__`,
            value: 'üåê `!traducir <idioma> <texto>` - Traduce entre ES/JP/EN\n*M√°x: 500 caracteres*\nüìç *Cualquier canal*',
            inline: false
          }
        )
        .setFooter({ text: `Demon Hunter Bot v1.5 ‚Ä¢ ${EMOJIS.FIRE} Total: 23+ comandos` })
        .setTimestamp();

      await message.reply({ embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} Comando de ayuda mostrado para ${message.author.tag}`);
    } catch (error) {
      console.error(`${EMOJIS.ERROR} Error mostrando comando de ayuda:`, error);
      await message.reply(`${MESSAGES.ERRORS.COMMAND_ERROR}`);
    }
  }

  // Comando para borrar mensajes de un usuario espec√≠fico
  if (message.content.toLowerCase().startsWith('!borrarmsg')) {
    try {
      // Verificar que el mensaje es de un servidor (no DM)
      if (!message.guild || !message.member) {
        return message.reply('‚ùå Este comando solo funciona en servidores.');
      }

      // Verificar permisos PRIMERO (antes del cooldown)
      // Esto evita que usuarios sin permisos activen el cooldown
      if (!message.member.permissions.has(PermissionFlagsBits.ManageMessages)) {
        return message.reply('‚ùå No tienes permisos para borrar mensajes. Necesitas el permiso "Administrar Mensajes".');
      }

      // Verificar permisos del bot
      if (!message.guild.members.me.permissions.has(PermissionFlagsBits.ManageMessages)) {
        return message.reply('‚ùå No tengo permisos para borrar mensajes. Por favor otorga el permiso "Administrar Mensajes" al bot.');
      }

      // Verificar permiso para leer historial de mensajes
      if (!message.guild.members.me.permissions.has(PermissionFlagsBits.ReadMessageHistory)) {
        return message.reply('‚ùå No tengo permisos para leer el historial de mensajes. Por favor otorga el permiso "Leer Historial de Mensajes" al bot.');
      }

      const userId = message.author.id;

      // Verificar cooldown (usando dataManager persistente)
      if (dataManager.hasCooldown(userId, 'borrarmsg')) {
        const timeLeft = dataManager.getCooldownTime(userId, 'borrarmsg');
        return message.reply(MESSAGES.ERRORS.COOLDOWN(timeLeft));
      }

      // Establecer cooldown INMEDIATAMENTE (antes de operaciones async)
      // Esto previene race conditions si el usuario ejecuta el comando dos veces r√°pido
      dataManager.setCooldown(userId, 'borrarmsg', COOLDOWN_SECONDS);

      // Parsear el argumento del comando
      const args = message.content.split(/\s+/);
      if (args.length < 2) {
        return message.reply('‚ùå Uso incorrecto. Usa: `!borrarmsg <@usuario>` o `!borrarmsg nombre#1234`');
      }

      const targetArg = args.slice(1).join(' ').trim();
      let targetUserId = null;
      let targetUserTag = null;
      let isDeletedUser = false;

      // M√©todo 1: Intentar obtener el usuario mencionado (m√°s confiable)
      if (message.mentions.users.size > 0) {
        const user = message.mentions.users.first();
        targetUserId = user.id;
        targetUserTag = user.tag;
        console.log(`[borrarmsg] Usuario encontrado por menci√≥n: ${targetUserTag} (${targetUserId})`);
      } 
      // M√©todo 2: Buscar por ID de usuario (si se proporciona un ID num√©rico)
      // Esto funciona incluso si el usuario ya no est√° en el servidor
      else if (/^\d{17,19}$/.test(targetArg)) {
        targetUserId = targetArg;
        try {
          // Intentar obtener informaci√≥n del usuario (puede funcionar aunque no est√© en el servidor)
          const user = await message.client.users.fetch(targetArg).catch(() => null);
          if (user) {
            targetUserTag = user.tag;
            console.log(`[borrarmsg] Usuario encontrado por ID: ${targetUserTag} (${targetUserId})`);
          } else {
            // Usuario no encontrado en el cache de Discord, pero podemos usar el ID
            targetUserTag = `Usuario eliminado (${targetUserId})`;
            isDeletedUser = true;
            console.log(`[borrarmsg] Usuario eliminado del servidor, usando ID: ${targetUserId}`);
          }
        } catch (error) {
          // Si no podemos obtener el usuario, usar el ID directamente
          targetUserId = targetArg;
          targetUserTag = `Usuario eliminado (${targetUserId})`;
          isDeletedUser = true;
          console.log(`[borrarmsg] Usando ID directamente: ${targetUserId}`);
        }
      }
      // M√©todo 3: Buscar por nombre de usuario (solo si est√° en el servidor)
      else {
        // Primero buscar en el cache
        let targetMember = message.guild.members.cache.find(m =>
          m.user.tag.toLowerCase() === targetArg.toLowerCase() ||
          m.user.username.toLowerCase() === targetArg.toLowerCase() ||
          m.displayName.toLowerCase() === targetArg.toLowerCase() ||
          m.user.tag.toLowerCase().includes(targetArg.toLowerCase()) ||
          m.user.username.toLowerCase().includes(targetArg.toLowerCase()) ||
          m.displayName.toLowerCase().includes(targetArg.toLowerCase())
        );

        // Si no est√° en cache, intentar fetch (solo si el servidor no es muy grande)
        if (!targetMember && message.guild.memberCount < 1000) {
          try {
            const members = await message.guild.members.fetch({ query: targetArg, limit: 10 });
            targetMember = members.find(m =>
              m.user.tag.toLowerCase() === targetArg.toLowerCase() ||
              m.user.username.toLowerCase() === targetArg.toLowerCase() ||
              m.displayName.toLowerCase() === targetArg.toLowerCase() ||
              m.user.tag.toLowerCase().includes(targetArg.toLowerCase()) ||
              m.user.username.toLowerCase().includes(targetArg.toLowerCase()) ||
              m.displayName.toLowerCase().includes(targetArg.toLowerCase())
            );
          } catch (error) {
            console.log(`[borrarmsg] Error en fetch de miembros: ${error.message}`);
          }
        }

        if (targetMember) {
          targetUserId = targetMember.user.id;
          targetUserTag = targetMember.user.tag;
          console.log(`[borrarmsg] Usuario encontrado por nombre: ${targetUserTag} (${targetUserId})`);
        }
      }

      if (!targetUserId) {
        return message.reply(`‚ùå No se pudo encontrar al usuario "${targetArg}".\nüí° **Sugerencias:**\n‚Ä¢ Usa una menci√≥n: \`!borrarmsg @usuario\`\n‚Ä¢ Usa el nombre completo: \`!borrarmsg usuario#1234\`\n‚Ä¢ Usa el ID del usuario: \`!borrarmsg 123456789012345678\` (funciona incluso si el usuario ya no est√° en el servidor)`);
      }

      // Primero contar cu√°ntos mensajes hay
      const countMsg = await message.reply(`üîç Buscando mensajes de ${targetUserTag}...`);

      let messageCount = 0;
      let fetchMore = true;
      let lastMessageId = null;

      while (fetchMore) {
        const fetchOptions = { limit: 100 };
        if (lastMessageId) {
          fetchOptions.before = lastMessageId;
        }

        const fetchedMessages = await message.channel.messages.fetch(fetchOptions);

        if (fetchedMessages.size === 0) {
          fetchMore = false;
          break;
        }

        const targetMessages = fetchedMessages.filter(msg => msg.author.id === targetUserId);
        messageCount += targetMessages.size;

        lastMessageId = fetchedMessages.last()?.id;

        if (fetchedMessages.size < 100) {
          fetchMore = false;
        }

        // Limitar a 500 mensajes
        if (messageCount >= 500) {
          fetchMore = false;
          break;
        }
      }

      if (messageCount === 0) {
        return countMsg.edit(`‚ùå No se encontraron mensajes de ${targetUserTag} en este canal.`);
      }

      // Verificar si ya hay una operaci√≥n de borrado en proceso en este canal
      if (channelLocks.has(message.channel.id)) {
        return countMsg.edit('‚ùå Ya hay una operaci√≥n de borrado en proceso en este canal. Por favor espera a que termine.');
      }

      // Establecer lock para este canal
      channelLocks.add(message.channel.id);

      // Crear botones de confirmaci√≥n
      const confirmButton = new ButtonBuilder()
        .setCustomId('confirm_delete')
        .setLabel('‚úÖ Confirmar')
        .setStyle(ButtonStyle.Danger);

      const cancelButton = new ButtonBuilder()
        .setCustomId('cancel_delete')
        .setLabel('‚ùå Cancelar')
        .setStyle(ButtonStyle.Secondary);

      const row = new ActionRowBuilder()
        .addComponents(confirmButton, cancelButton);

      const userDisplayName = isDeletedUser ? `Usuario eliminado (ID: ${targetUserId})` : targetUserTag;
      await countMsg.edit({
        content: `‚ö†Ô∏è Se encontraron **${messageCount}** mensaje(s) de ${userDisplayName}.\n¬øEst√°s seguro que deseas borrarlos? Tendr√°s ${UNDO_TIMEOUT_MINUTES} minutos para deshacerlo.`,
        components: [row]
      });

      // Esperar respuesta del bot√≥n
      const filter = i => {
        return (i.customId === 'confirm_delete' || i.customId === 'cancel_delete') && i.user.id === message.author.id;
      };

      try {
        const interaction = await countMsg.awaitMessageComponent({ filter, time: 30000 });

        if (interaction.customId === 'cancel_delete') {
          await interaction.update({
            content: '‚ùå Operaci√≥n cancelada.',
            components: []
          });
          // Liberar lock del canal
          channelLocks.delete(message.channel.id);
          return;
        }
      } catch (error) {
        if (error.message && (error.message.includes('time') || error.message.includes('expired'))) {
          await countMsg.edit({
            content: MESSAGES.GENERIC.TIMEOUT_DELETE(30),
            components: []
          });
        } else {
          await countMsg.edit({
            content: `‚ùå Ocurri√≥ un error: ${error.message || 'Error desconocido'}. Por favor, intenta de nuevo.`,
            components: []
          });
        }
        channelLocks.delete(message.channel.id);
        return;
      }

        // Usuario confirm√≥, proceder a borrar
        await interaction.update({
          content: `üóëÔ∏è Borrando mensajes de ${userDisplayName}...`,
          components: []
        });

        // Guardar mensajes antes de borrar (para poder deshacerlo)
        const savedMessages = [];
        let totalDeleted = 0;
        fetchMore = true;
        lastMessageId = null;

        while (fetchMore) {
          const fetchOptions = { limit: 100 };
          if (lastMessageId) {
            fetchOptions.before = lastMessageId;
          }

          const fetchedMessages = await message.channel.messages.fetch(fetchOptions);

          if (fetchedMessages.size === 0) {
            fetchMore = false;
            break;
          }

          const targetMessages = fetchedMessages.filter(msg => msg.author.id === targetUserId);

          if (targetMessages.size > 0) {
            // Guardar informaci√≥n de los mensajes
            for (const [, msg] of targetMessages) {
              // Obtener el tag del autor (puede ser null si el usuario fue eliminado)
              const authorId = msg.author ? msg.author.id : targetUserId;
              const authorTag = msg.author ? msg.author.tag : `Usuario eliminado (${authorId})`;
              const authorAvatarURL = msg.author ? msg.author.displayAvatarURL() : null;
              
              savedMessages.push({
                content: msg.content,
                authorId: authorId,
                authorTag: authorTag,
                authorAvatarURL: authorAvatarURL,
                timestamp: msg.createdTimestamp,
                attachments: msg.attachments.map(att => ({
                  url: att.url,
                  name: att.name
                })),
                embeds: msg.embeds
              });
            }

            // Discord solo permite borrar mensajes de menos de 14 d√≠as en bulkDelete
            const recentMessages = targetMessages.filter(msg =>
              Date.now() - msg.createdTimestamp < 14 * 24 * 60 * 60 * 1000
            );

            if (recentMessages.size > 0) {
              if (recentMessages.size === 1) {
                await recentMessages.first().delete();
                totalDeleted += 1;
              } else {
                const deleted = await message.channel.bulkDelete(recentMessages, true);
                totalDeleted += deleted.size;
              }
            }

            // Mensajes antiguos (m√°s de 14 d√≠as)
            const oldMessages = targetMessages.filter(msg =>
              Date.now() - msg.createdTimestamp >= 14 * 24 * 60 * 60 * 1000
            );

            for (const [, oldMsg] of oldMessages) {
              try {
                await oldMsg.delete();
                totalDeleted += 1;
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (error) {
                console.error(`Error borrando mensaje antiguo ${oldMsg.id}:`, error.message);
              }
            }
          }

          lastMessageId = fetchedMessages.last()?.id;

          if (fetchedMessages.size < 100) {
            fetchMore = false;
          }

          if (totalDeleted >= 500) {
            fetchMore = false;
          }
        }

        // Guardar en cache para deshacer (usar channelId como key √∫nica)
        // Si ya existe una entrada para este canal, cancelar su timeout primero
        const existingEntry = deletedMessagesCache.get(message.channel.id);
        if (existingEntry && existingEntry.timeoutId) {
          clearTimeout(existingEntry.timeoutId);
        }

        // Crear nuevo timeout y guardarlo junto con los datos
        const timeoutId = setTimeout(() => {
          deletedMessagesCache.delete(message.channel.id);
        }, UNDO_TIMEOUT_MINUTES * 60 * 1000);

        deletedMessagesCache.set(message.channel.id, {
          messages: savedMessages,
          deletedBy: message.author.id,
          targetUser: userDisplayName,
          timestamp: Date.now(),
          timeoutId: timeoutId
        });

        await interaction.editReply({
          content: `‚úÖ Se borraron **${totalDeleted}** mensaje(s) de ${userDisplayName}\nüí° Usa \`!deshacerborrado\` en los pr√≥ximos ${UNDO_TIMEOUT_MINUTES} minutos para restaurarlos.`,
          components: []
        });

        console.log(`‚úì ${message.author.tag} borr√≥ ${totalDeleted} mensajes de ${userDisplayName} en #${message.channel.name}`);

        // Liberar lock del canal (operaci√≥n completada exitosamente)
        channelLocks.delete(message.channel.id);

    } catch (error) {
      console.error('Error ejecutando comando borrarmsg:', error);
      await message.reply('‚ùå Ocurri√≥ un error al intentar borrar los mensajes. Por favor intenta de nuevo m√°s tarde.');
      // Liberar lock del canal (error)
      channelLocks.delete(message.channel.id);
    }
  }

  // Comando para deshacer borrado de mensajes
  if (message.content.toLowerCase() === '!deshacerborrado') {
    try {
      // Verificar permisos del usuario
      if (!message.member.permissions.has(PermissionFlagsBits.ManageMessages)) {
        return message.reply('‚ùå No tienes permisos para usar este comando. Necesitas el permiso "Administrar Mensajes".');
      }

      // Verificar permisos del bot para crear webhooks
      if (!message.guild.members.me.permissions.has(PermissionFlagsBits.ManageWebhooks)) {
        return message.reply('‚ùå No tengo permisos para restaurar mensajes. Por favor otorga el permiso "Administrar Webhooks" al bot.');
      }

      // Buscar operaci√≥n de borrado reciente en este canal (ahora el key ES el channelId)
      const entry = deletedMessagesCache.get(message.channel.id);

      if (!entry) {
        return message.reply(`‚ùå No hay mensajes borrados para restaurar en este canal (o ya pasaron ${UNDO_TIMEOUT_MINUTES} minutos).`);
      }

      const statusMsg = await message.reply(`üîÑ Restaurando ${entry.messages.length} mensajes de ${entry.targetUser}...`);

      // Obtener o crear webhook para el canal
      const webhooks = await message.channel.fetchWebhooks();
      let webhook = webhooks.find(wh => wh.owner.id === client.user.id);

      if (!webhook) {
        webhook = await message.channel.createWebhook({
          name: 'Restaurador de Mensajes',
          reason: 'Webhook para restaurar mensajes borrados'
        });
      }

      // Restaurar mensajes en orden (del m√°s antiguo al m√°s reciente)
      const sortedMessages = entry.messages.sort((a, b) => a.timestamp - b.timestamp);
      let restored = 0;

      for (const msgData of sortedMessages) {
        try {
          const webhookOptions = {
            content: msgData.content || null,
            username: msgData.authorTag,
            avatarURL: msgData.authorAvatarURL,
            embeds: msgData.embeds
          };

          // Agregar archivos si los hay
          if (msgData.attachments && msgData.attachments.length > 0) {
            webhookOptions.files = msgData.attachments.map(att => att.url);
          }

          await webhook.send(webhookOptions);
          restored++;

          // Peque√±o delay para evitar rate limits
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.error('Error restaurando mensaje:', error.message);
        }
      }

      // Cancelar timeout y eliminar del cache
      if (entry.timeoutId) {
        clearTimeout(entry.timeoutId);
      }
      deletedMessagesCache.delete(message.channel.id);

      await statusMsg.edit(`‚úÖ Se restauraron **${restored}** de **${entry.messages.length}** mensajes.`);
      console.log(`‚úì ${message.author.tag} restaur√≥ ${restored} mensajes en #${message.channel.name}`);

    } catch (error) {
      console.error('Error ejecutando comando deshacerborrado:', error);
      await message.reply('‚ùå Ocurri√≥ un error al intentar restaurar los mensajes. Por favor intenta de nuevo m√°s tarde.');
    }
  }

  // Comando para unirse al canal de voz sin hablar (lectura autom√°tica)
  if (message.content.toLowerCase() === '!join') {
    try {
      // Verificar que el usuario est√° en un canal de voz
      const userVoiceChannel = message.member.voice.channel;

      if (!userVoiceChannel) {
        return message.reply('‚ùå Debes estar en un canal de voz para usar este comando.');
      }

      // Verificar si ya est√° conectado
      const guildId = message.guild.id;

      if (isConnected(guildId)) {
        return message.reply('‚úÖ Ya estoy conectado a un canal de voz. Usa `!salir` para desconectarme primero.');
      }

      // Verificar permisos del bot
      const permissions = userVoiceChannel.permissionsFor(message.guild.members.me);

      if (!permissions.has(PermissionFlagsBits.Connect)) {
        return message.reply('‚ùå No tengo permisos para conectarme a tu canal de voz. Por favor otorga el permiso "Conectar".');
      }

      if (!permissions.has(PermissionFlagsBits.Speak)) {
        return message.reply('‚ùå No tengo permisos para hablar en tu canal de voz. Por favor otorga el permiso "Hablar".');
      }

      // Conectar al canal de voz
      await connectToVoiceChannel(userVoiceChannel);
      // Guardar el canal de texto donde se ejecut√≥ el comando (chat de voz)
      setVoiceChannelTextChannel(guildId, userVoiceChannel, message.channel.id);
      await message.reply(`‚úÖ Conectado a **${userVoiceChannel.name}**\nüí¨ Ahora leer√© autom√°ticamente los mensajes que escriban los usuarios en este canal de texto (chat de voz).`);
      console.log(`‚úì ${message.author.tag} conect√≥ el bot a ${userVoiceChannel.name} (modo lectura autom√°tica, canal de texto: ${message.channel.name})`);

    } catch (error) {
      console.error('Error ejecutando comando join:', error);
      await message.reply('‚ùå Ocurri√≥ un error al intentar conectarme al canal de voz.');
    }
  }

  // Comando para hacer que el bot hable en el canal de voz
  if (message.content.toLowerCase().startsWith('!hablar')) {
    try {
      // Parsear el texto a hablar
      const args = message.content.split(/\s+/).slice(1);

      if (args.length === 0) {
        return message.reply('‚ùå Uso incorrecto. Usa: `!hablar <texto>` - Ejemplo: `!hablar Hola a todos`');
      }

      const textToSpeak = args.join(' ');

      // Verificar que el usuario est√° en un canal de voz
      const userVoiceChannel = message.member.voice.channel;

      if (!userVoiceChannel) {
        return message.reply('‚ùå Debes estar en un canal de voz para usar este comando.');
      }

      // Verificar permisos del bot
      const permissions = userVoiceChannel.permissionsFor(message.guild.members.me);

      if (!permissions.has(PermissionFlagsBits.Connect)) {
        return message.reply('‚ùå No tengo permisos para conectarme a tu canal de voz. Por favor otorga el permiso "Conectar".');
      }

      if (!permissions.has(PermissionFlagsBits.Speak)) {
        return message.reply('‚ùå No tengo permisos para hablar en tu canal de voz. Por favor otorga el permiso "Hablar".');
      }

      // Conectar al canal de voz (si no est√° conectado)
      const guildId = message.guild.id;

      if (!isConnected(guildId)) {
        await connectToVoiceChannel(userVoiceChannel);
        // Guardar el canal de texto donde se ejecut√≥ el comando
        setVoiceChannelTextChannel(guildId, userVoiceChannel, message.channel.id);
        await message.reply(`‚úÖ Conectado a **${userVoiceChannel.name}**`);
      }

      // Agregar nombre del usuario al inicio del mensaje
      const userName = message.member.displayName || message.author.username;
      const fullMessage = `${userName} dice: ${textToSpeak}`;

      // Hablar el texto con el nombre del usuario
      await speakText(guildId, fullMessage, 'es');

      await message.react('üîä');
      console.log(`‚úì ${message.author.tag} us√≥ TTS: "${fullMessage}"`);

    } catch (error) {
      console.error('Error ejecutando comando hablar:', error);
      await message.reply('‚ùå Ocurri√≥ un error al intentar hablar. Aseg√∫rate de que estoy conectado a un canal de voz.');
    }
  }

  // Comando para desconectar el bot del canal de voz
  if (message.content.toLowerCase() === '!salir') {
    try {
      const guildId = message.guild.id;

      if (!isConnected(guildId)) {
        return message.reply('‚ùå No estoy conectado a ning√∫n canal de voz.');
      }

      disconnectFromVoiceChannel(guildId);
      lastVoiceSpeakers.delete(guildId); // Limpiar registro de √∫ltimos hablantes
      await message.reply('üëã Me he desconectado del canal de voz.');
      console.log(`‚úì ${message.author.tag} desconect√≥ el bot del canal de voz`);

    } catch (error) {
      console.error('Error ejecutando comando salir:', error);
      await message.reply('‚ùå Ocurri√≥ un error al intentar desconectarme.');
    }
  }

  // ==================== COMANDOS DE TEXTO: SISTEMA DE HONOR ====================

  // !honor - Mostrar honor del usuario
  if (message.content.toLowerCase() === '!honor') {
    try {
      const userId = message.author.id;
      const guildId = message.guild.id;

      const userData = dataManager.getUser(userId, guildId);
      const currentHonor = userData.honor;
      const currentRank = userData.rank;

      // Calcular progreso hacia siguiente rango
      let nextRank = null;
      let honorNeeded = 0;
      let progressPercent = 0;
      let rankThresholds = {
        'Ronin': { next: 'Samurai', threshold: CONSTANTS.HONOR.RANK_THRESHOLDS.SAMURAI },
        'Samurai': { next: 'Daimyo', threshold: CONSTANTS.HONOR.RANK_THRESHOLDS.DAIMYO },
        'Daimyo': { next: 'Shogun', threshold: CONSTANTS.HONOR.RANK_THRESHOLDS.SHOGUN },
        'Shogun': { next: null, threshold: null }
      };

      if (currentRank !== 'Shogun') {
        nextRank = rankThresholds[currentRank].next;
        const threshold = rankThresholds[currentRank].threshold;
        honorNeeded = threshold - currentHonor;

        if (currentRank === 'Ronin') {
          progressPercent = Math.min(100, (currentHonor / CONSTANTS.HONOR.RANK_THRESHOLDS.SAMURAI) * 100);
        } else if (currentRank === 'Samurai') {
          const start = CONSTANTS.HONOR.RANK_THRESHOLDS.SAMURAI;
          const end = CONSTANTS.HONOR.RANK_THRESHOLDS.DAIMYO;
          progressPercent = Math.min(100, ((currentHonor - start) / (end - start)) * 100);
        } else if (currentRank === 'Daimyo') {
          const start = CONSTANTS.HONOR.RANK_THRESHOLDS.DAIMYO;
          const end = CONSTANTS.HONOR.RANK_THRESHOLDS.SHOGUN;
          progressPercent = Math.min(100, ((currentHonor - start) / (end - start)) * 100);
        }
      } else {
        progressPercent = 100;
      }

      const barLength = CONSTANTS.LEADERBOARDS.PROGRESS_BAR_LENGTH;
      const filledBars = Math.floor((progressPercent / 100) * barLength);
      const emptyBars = barLength - filledBars;
      const progressBar = '‚ñà'.repeat(filledBars) + '‚ñë'.repeat(emptyBars);

      const embed = new EmbedBuilder()
        .setColor(COLORS.HONOR)
        .setTitle(`${EMOJIS.HONOR} Honor de ${message.member.displayName || message.author.username}`)
        .setDescription(`Tu camino samurai en **${message.guild.name}**`)
        .addFields(
          {
            name: `${EMOJIS.STAR} Honor Actual`,
            value: `**${currentHonor}** puntos`,
            inline: true
          },
          {
            name: `${getRankEmoji(currentRank)} Rango`,
            value: `**${currentRank}**`,
            inline: true
          },
          {
            name: '\u200B',
            value: '\u200B',
            inline: true
          }
        )
        .setThumbnail(message.author.displayAvatarURL())
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      if (currentRank !== 'Shogun') {
        embed.addFields({
          name: `${EMOJIS.LOADING} Progreso hacia ${nextRank}`,
          value: `${progressBar} ${progressPercent.toFixed(1)}%\n${EMOJIS.KATANA} Faltan **${honorNeeded}** puntos de honor`,
          inline: false
        });
      } else {
        embed.addFields({
          name: `${EMOJIS.CROWN} Rango M√°ximo Alcanzado`,
          value: `${EMOJIS.TROPHY} Has alcanzado el rango m√°s alto del dojo. ¬°Tu leyenda es eterna!`,
          inline: false
        });
      }

      embed.addFields({
        name: `${EMOJIS.SCROLL} Estad√≠sticas`,
        value: `${EMOJIS.MESSAGE} Mensajes: **${userData.stats?.messagesCount || 0}**\n${EMOJIS.VOICE} Minutos en voz: **${userData.stats?.voiceMinutes || 0}**\n${EMOJIS.DUEL} Duelos ganados: **${userData.stats?.duelsWon || 0}**`,
        inline: false
      });

      await message.reply({ embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} ${message.author.tag} consult√≥ su honor (${currentHonor} honor, ${currentRank})`);
    } catch (error) {
      console.error('Error ejecutando comando !honor:', error);
      await message.reply('‚ùå Ocurri√≥ un error al consultar tu honor.');
    }
  }

  // !rango - Mostrar rango del usuario
  if (message.content.toLowerCase() === '!rango') {
    try {
      const userId = message.author.id;
      const guildId = message.guild.id;

      const userData = dataManager.getUser(userId, guildId);
      const currentRank = userData.rank;
      const currentHonor = userData.honor;

      const rankInfo = {
        'Ronin': {
          description: 'Un guerrero sin maestro que busca su camino en el dojo.',
          benefits: [
            '‚Ä¢ Acceso a comandos b√°sicos del dojo',
            '‚Ä¢ Ganancia de honor por actividad',
            '‚Ä¢ Participaci√≥n en el ranking'
          ],
          honorRange: '0 - 499',
          nextRank: 'Samurai (500 honor)',
          color: COLORS.RONIN,
          emoji: EMOJIS.RONIN
        },
        'Samurai': {
          description: 'Un guerrero disciplinado que ha demostrado su val√≠a en el dojo.',
          benefits: [
            '‚Ä¢ Todos los beneficios de Ronin',
            '‚Ä¢ Mayor ganancia de honor diaria',
            '‚Ä¢ Acceso a comandos de clan',
            '‚Ä¢ Emblema especial en el ranking'
          ],
          honorRange: '500 - 1,999',
          nextRank: 'Daimyo (2,000 honor)',
          color: COLORS.SAMURAI,
          emoji: EMOJIS.SAMURAI
        },
        'Daimyo': {
          description: 'Un se√±or feudal respetado, l√≠der entre los guerreros del dojo.',
          benefits: [
            '‚Ä¢ Todos los beneficios de Samurai',
            '‚Ä¢ Recompensas diarias mejoradas',
            '‚Ä¢ Capacidad de crear clanes',
            '‚Ä¢ Prioridad en eventos del dojo',
            '‚Ä¢ Emblema dorado en el ranking'
          ],
          honorRange: '2,000 - 4,999',
          nextRank: 'Shogun (5,000 honor)',
          color: COLORS.DAIMYO,
          emoji: EMOJIS.DAIMYO
        },
        'Shogun': {
          description: 'El comandante supremo, maestro absoluto del arte samurai.',
          benefits: [
            '‚Ä¢ Todos los beneficios de Daimyo',
            '‚Ä¢ M√°ximas recompensas diarias',
            '‚Ä¢ Acceso a comandos exclusivos',
            '‚Ä¢ Emblema legendario en el ranking',
            '‚Ä¢ Reconocimiento eterno en el dojo',
            '‚Ä¢ Rol especial (si configurado)'
          ],
          honorRange: '5,000+',
          nextRank: 'Rango M√°ximo',
          color: COLORS.SHOGUN,
          emoji: EMOJIS.SHOGUN
        }
      };

      const info = rankInfo[currentRank];

      const embed = new EmbedBuilder()
        .setColor(info.color)
        .setTitle(`${info.emoji} ${currentRank}`)
        .setDescription(info.description)
        .addFields(
          {
            name: `${EMOJIS.SCROLL} Rango de Honor`,
            value: info.honorRange,
            inline: true
          },
          {
            name: `${EMOJIS.HONOR} Tu Honor`,
            value: `${currentHonor} puntos`,
            inline: true
          },
          {
            name: '\u200B',
            value: '\u200B',
            inline: true
          },
          {
            name: `${EMOJIS.GIFT} Beneficios del Rango`,
            value: info.benefits.join('\n'),
            inline: false
          },
          {
            name: `${EMOJIS.KATANA} Pr√≥ximo Rango`,
            value: info.nextRank,
            inline: false
          }
        )
        .setThumbnail(message.author.displayAvatarURL())
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      await message.reply({ embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} ${message.author.tag} consult√≥ su rango (${currentRank})`);
    } catch (error) {
      console.error('Error ejecutando comando !rango:', error);
      await message.reply('‚ùå Ocurri√≥ un error al consultar tu rango.');
    }
  }

  // !top - Leaderboard de honor
  if (message.content.toLowerCase() === '!top') {
    try {
      const guildId = message.guild.id;

      const statusMsg = await message.reply(`${EMOJIS.LOADING} Consultando el ranking de honor...`);

      const guildUsers = dataManager.getGuildUsers(guildId);

      if (guildUsers.length === 0) {
        return statusMsg.edit(`${EMOJIS.INFO} A√∫n no hay guerreros registrados en el dojo. ¬°Usa comandos para ganar honor!`);
      }

      const sortedUsers = guildUsers.sort((a, b) => b.honor - a.honor);
      const top10 = sortedUsers.slice(0, CONSTANTS.LEADERBOARDS.TOP_DISPLAY_COUNT);

      const userIndex = sortedUsers.findIndex(u => u.userId === message.author.id);
      const userPosition = userIndex >= 0 ? userIndex + 1 : null;
      const userHonor = userIndex >= 0 ? sortedUsers[userIndex].honor : 0;

      // Obtener displayNames del servidor (nombres modificados en el canal)
      const userIds = top10.map(u => u.userId);
      const displayNameMap = await fetchDisplayNamesBatch(message.guild, userIds);

      let description = '';

      for (let i = 0; i < top10.length; i++) {
        const user = top10[i];
        const position = i + 1;

        let positionEmoji = '';
        if (position === 1) positionEmoji = EMOJIS.FIRST;
        else if (position === 2) positionEmoji = EMOJIS.SECOND;
        else if (position === 3) positionEmoji = EMOJIS.THIRD;
        else positionEmoji = `\`${position}.\``;

        const rankEmoji = getRankEmoji(user.rank);
        const userName = displayNameMap.get(user.userId) || 'Usuario Desconocido';

        const isCurrentUser = user.userId === message.author.id;
        const highlight = isCurrentUser ? '**‚û§ ' : '';
        const highlightEnd = isCurrentUser ? '**' : '';

        description += `${positionEmoji} ${highlight}${rankEmoji} ${userName} - ${user.honor} honor${highlightEnd}\n`;
      }

      const embed = new EmbedBuilder()
        .setColor(COLORS.GOLD)
        .setTitle(`${EMOJIS.TROPHY} Ranking de Honor - ${message.guild.name}`)
        .setDescription(description)
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      if (userPosition !== null && userPosition > 10) {
        embed.addFields({
          name: `${EMOJIS.INFO} Tu Posici√≥n`,
          value: `**#${userPosition}** - ${userHonor} honor`,
          inline: false
        });
      } else if (userPosition === null) {
        embed.addFields({
          name: `${EMOJIS.INFO} Tu Posici√≥n`,
          value: 'No registrado - ¬°Usa comandos para ganar honor!',
          inline: false
        });
      }

      await statusMsg.edit({ content: null, embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} ${message.author.tag} consult√≥ el ranking de honor`);
    } catch (error) {
      console.error('Error ejecutando comando !top:', error);
      await message.reply('‚ùå Ocurri√≥ un error al consultar el ranking.');
    }
  }
});

// Manejador de Slash Commands (/)
client.on(Events.InteractionCreate, async (interaction) => {
  if (!interaction.isChatInputCommand()) return;

  const { commandName } = interaction;

  // Comandos que NO requieren estar en el canal de comandos
  const excludedCommands = ['traducir', 'hablar', 'join', 'salir', 'help', 'testwelcome', 'borrarmsg', 'deshacerborrado', 'tienda', 'duelo', 'sabiduria', 'fortuna', 'perfil'];
  
  // Verificar si el comando debe ejecutarse en un canal espec√≠fico
  if (config.commandsChannel && config.commandsChannel.enabled && config.commandsChannel.channelId) {
    if (!excludedCommands.includes(commandName)) {
      if (interaction.channel.id !== config.commandsChannel.channelId) {
        const commandsChannel = interaction.guild.channels.cache.get(config.commandsChannel.channelId);
        const channelName = commandsChannel ? commandsChannel.name : 'el canal de comandos';
        const channelMention = commandsChannel ? `<#${config.commandsChannel.channelId}>` : 'el canal de comandos';
        
        return interaction.reply({
          content: `‚ùå Este comando solo puede usarse en ${channelMention} (**${channelName}**).`,
          flags: MessageFlags.Ephemeral
        });
      }
    }
  }

  try {
    // /testwelcome
    if (commandName === 'testwelcome') {
      const userId = interaction.user.id;

      // Verificar cooldown (usando dataManager persistente)
      if (dataManager.hasCooldown(userId, 'testwelcome')) {
        const timeLeft = dataManager.getCooldownTime(userId, 'testwelcome');
        return interaction.reply({
          content: MESSAGES.ERRORS.COOLDOWN(timeLeft),
          flags: MessageFlags.Ephemeral
        });
      }

      // Establecer cooldown (se guarda en JSON)
      dataManager.setCooldown(userId, 'testwelcome', COOLDOWN_SECONDS);

      await interaction.deferReply();

      const member = interaction.guild.members.cache.get(interaction.user.id);
      if (!member) {
        return interaction.editReply('‚ùå No se pudo encontrar informaci√≥n del miembro.');
      }

      const attachment = await createWelcomeCard(member);
      await interaction.editReply({
        content: `${interaction.user}, aqu√≠ est√° la vista previa de tu tarjeta de bienvenida:`,
        files: [attachment]
      });

      console.log(`‚úì Tarjeta de bienvenida de prueba enviada para ${interaction.user.tag} (slash)`);
    }

    // /help
    else if (commandName === 'help') {
      // Obtener nombres de canales si est√°n configurados
      const commandsChannel = config.commandsChannel && config.commandsChannel.enabled && config.commandsChannel.channelId
        ? interaction.guild.channels.cache.get(config.commandsChannel.channelId)
        : null;
      const shopChannel = config.shopChannel && config.shopChannel.enabled && config.shopChannel.channelId
        ? interaction.guild.channels.cache.get(config.shopChannel.channelId)
        : null;
      const combatChannel = config.combatChannel && config.combatChannel.enabled && config.combatChannel.channelId
        ? interaction.guild.channels.cache.get(config.combatChannel.channelId)
        : null;

      const commandsChannelName = commandsChannel ? `**${commandsChannel.name}**` : 'Cualquier canal';
      const shopChannelName = shopChannel ? `**${shopChannel.name}**` : 'Cualquier canal';
      const combatChannelName = combatChannel ? `**${combatChannel.name}**` : 'Cualquier canal';

      // Dividir en m√∫ltiples embeds para evitar el l√≠mite de 25 campos
      const embed1 = new EmbedBuilder()
        .setColor(COLORS.PRIMARY)
        .setTitle(`${EMOJIS.TORII} Comandos del Dojo - Demon Hunter`)
        .setDescription(`Bienvenido al manual del guerrero, ${interaction.member?.displayName || interaction.user.username}. Aqu√≠ encontrar√°s todos los comandos disponibles.\n\n${EMOJIS.KATANA} **Tip:** Escribe \`/\` en Discord para ver todos los comandos con autocompletar!`)
        .addFields(
          // ========== BIENVENIDA Y AYUDA ==========
          {
            name: `${EMOJIS.TORII} __BIENVENIDA Y AYUDA__`,
            value: 'üé® `/testwelcome` - Vista previa de tarjeta de bienvenida\n‚ùì `/help` - Muestra este mensaje\nüìç *Cualquier canal*',
            inline: false
          },
          // ========== MODERACI√ìN ==========
          {
            name: `${EMOJIS.KATANA} __MODERACI√ìN__`,
            value: 'üóëÔ∏è `/borrarmsg` - Elimina mensajes de un usuario\nüîÑ `/deshacerborrado` - Restaura mensajes eliminados\n*Req: Administrar Mensajes*\nüìç *Cualquier canal*',
            inline: false
          },
          // ========== VOZ / TTS ==========
          {
            name: `${EMOJIS.VOICE} __VOZ / TTS__`,
            value: 'üîó `/join` - Bot se une a voz y lee mensajes\nüîä `/hablar <texto>` - Text-to-speech en espa√±ol\nüëã `/salir` - Desconecta el bot de voz\nüìç *Cualquier canal*',
            inline: false
          },
          // ========== HONOR Y RANGOS ==========
          {
            name: `${EMOJIS.HONOR} __HONOR Y RANGOS__`,
            value: `‚≠ê \`/honor [@usuario]\` - Ver honor y progreso de rango\n‚öîÔ∏è \`/rango\` - Info del sistema de rangos\nüèÜ \`/top\` - Ranking de honor (top 10)\nüìç *${commandsChannelName}*`,
            inline: false
          },
          // ========== ECONOM√çA ==========
          {
            name: `${EMOJIS.KOKU} __ECONOM√çA__`,
            value: `üìÖ \`/daily\` - Recompensa diaria de koku\nüí∞ \`/balance\` - Ver tu koku, honor y racha\nüí∏ \`/pay\` - Transferir koku a otro usuario\nüìä \`/leaderboard\` - Rankings interactivos del dojo\nüìç *${commandsChannelName}*`,
            inline: false
          },
          // ========== CLANES ==========
          {
            name: `${EMOJIS.CLAN} __CLANES__`,
            value: `üèØ \`/clan crear\` - Crear tu propio clan\nüèØ \`/clan info\` - Ver informaci√≥n de un clan\nüèØ \`/clan unirse\` - Unirse a un clan\nüèØ \`/clan salir\` - Abandonar tu clan actual\nüìç *${commandsChannelName}*`,
            inline: false
          },
          {
            name: `${EMOJIS.CLAN} __CLANES (CONT.)__`,
            value: `üèØ \`/clan miembros\` - Lista de miembros del clan\nüèØ \`/clan top\` - Ranking de clanes\nüèØ \`/clan invitar\` - Invitar usuario al clan\nüèØ \`/clan expulsar\` - Expulsar miembro del clan\nüìç *${commandsChannelName}*`,
            inline: false
          },
          // ========== TIENDA ==========
          {
            name: `${EMOJIS.SHOP} __TIENDA__`,
            value: `üè™ \`/tienda ver\` - Ver productos disponibles\nüõí \`/tienda comprar\` - Comprar un item\nüì¶ \`/tienda inventario\` - Ver tu inventario\nüìç *${shopChannelName}*`,
            inline: false
          },
          // ========== COMBATE Y JUEGOS ==========
          {
            name: `${EMOJIS.DUEL} __COMBATE Y JUEGOS__`,
            value: `‚öîÔ∏è \`/duelo @usuario\` - Desaf√≠a a un duelo de honor\nüìú \`/sabiduria\` - Citas de maestros samurai\nüé¥ \`/fortuna\` - Omikuji (fortuna diaria)\nüë§ \`/perfil [@usuario]\` - Ver perfil completo de guerrero\nüìç *${combatChannelName}*`,
            inline: false
          },
          // ========== UTILIDADES ==========
          {
            name: `${EMOJIS.TRANSLATION} __UTILIDADES__`,
            value: 'üåê `/traducir` - Traduce entre ES/JP/EN\n*M√°x: 500 caracteres*\nüìç *Cualquier canal*',
            inline: false
          }
        )
        .setFooter({ text: `Demon Hunter Bot v1.5 ‚Ä¢ ${EMOJIS.FIRE} Total: 23 comandos slash` })
        .setTimestamp();

      await interaction.reply({ embeds: [embed1] });
      console.log(`${EMOJIS.SUCCESS} Comando de ayuda mostrado para ${interaction.user.tag} (slash)`);
    }

    // /borrarmsg
    else if (commandName === 'borrarmsg') {
      // Verificar permisos
      if (!interaction.memberPermissions.has(PermissionFlagsBits.ManageMessages)) {
        return interaction.reply({ content: '‚ùå No tienes permisos para borrar mensajes. Necesitas el permiso "Administrar Mensajes".', flags: MessageFlags.Ephemeral });
      }

      if (!interaction.guild.members.me.permissions.has(PermissionFlagsBits.ManageMessages)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para borrar mensajes. Por favor otorga el permiso "Administrar Mensajes" al bot.', flags: MessageFlags.Ephemeral });
      }

      if (!interaction.guild.members.me.permissions.has(PermissionFlagsBits.ReadMessageHistory)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para leer el historial de mensajes. Por favor otorga el permiso "Leer Historial de Mensajes" al bot.', flags: MessageFlags.Ephemeral });
      }

      const userId = interaction.user.id;

      // Verificar cooldown (usando dataManager persistente)
      if (dataManager.hasCooldown(userId, 'borrarmsg')) {
        const timeLeft = dataManager.getCooldownTime(userId, 'borrarmsg');
        return interaction.reply({
          content: MESSAGES.ERRORS.COOLDOWN(timeLeft),
          flags: MessageFlags.Ephemeral
        });
      }

      // Establecer cooldown (se guarda en JSON)
      dataManager.setCooldown(userId, 'borrarmsg', COOLDOWN_SECONDS);

      // Obtener usuario de la opci√≥n de usuario o del ID
      const targetUserOption = interaction.options.getUser('usuario');
      const targetIdOption = interaction.options.getString('id_usuario');

      let targetUserId = null;
      let targetUserTag = null;
      let isDeletedUser = false;

      // Si se proporcion√≥ un usuario mediante la opci√≥n de usuario
      if (targetUserOption) {
        targetUserId = targetUserOption.id;
        targetUserTag = targetUserOption.tag;
      }
      // Si se proporcion√≥ un ID
      else if (targetIdOption) {
        const idArg = targetIdOption.trim();
        if (/^\d{17,19}$/.test(idArg)) {
          targetUserId = idArg;
          try {
            const user = await interaction.client.users.fetch(targetUserId);
            targetUserTag = user.tag;
          } catch {
            targetUserTag = `Usuario eliminado (${targetUserId})`;
            isDeletedUser = true;
          }
        } else {
          return interaction.reply({ content: '‚ùå Formato inv√°lido. El ID del usuario debe tener 17-19 d√≠gitos.', flags: MessageFlags.Ephemeral });
        }
      }
      // Si no se proporcion√≥ ninguna opci√≥n
      else {
        return interaction.reply({ content: '‚ùå Debes proporcionar un usuario o un ID de usuario. Usa `/borrarmsg usuario:@Usuario` o `/borrarmsg id_usuario:123456789012345678`', flags: MessageFlags.Ephemeral });
      }

      if (!targetUserId) {
        return interaction.reply({ content: '‚ùå No se pudo identificar al usuario.', flags: MessageFlags.Ephemeral });
      }

      await interaction.deferReply();

      // Contar mensajes
      let messageCount = 0;
      let fetchMore = true;
      let lastMessageId = null;

      while (fetchMore) {
        const fetchOptions = { limit: 100 };
        if (lastMessageId) fetchOptions.before = lastMessageId;

        const fetchedMessages = await interaction.channel.messages.fetch(fetchOptions);
        if (fetchedMessages.size === 0) {
          fetchMore = false;
          break;
        }

        const targetMessages = fetchedMessages.filter(msg => msg.author.id === targetUserId);
        messageCount += targetMessages.size;
        lastMessageId = fetchedMessages.last()?.id;

        if (fetchedMessages.size < 100 || messageCount >= 500) {
          fetchMore = false;
        }
      }

      const userDisplayName = isDeletedUser ? `Usuario eliminado (ID: ${targetUserId})` : targetUserTag;
      if (messageCount === 0) {
        return interaction.editReply(`‚ùå No se encontraron mensajes de ${userDisplayName} en este canal.`);
      }

      if (channelLocks.has(interaction.channel.id)) {
        return interaction.editReply('‚ùå Ya hay una operaci√≥n de borrado en proceso en este canal. Por favor espera a que termine.');
      }

      channelLocks.add(interaction.channel.id);

      // Crear botones
      const confirmButton = new ButtonBuilder()
        .setCustomId('confirm_delete')
        .setLabel('‚úÖ Confirmar')
        .setStyle(ButtonStyle.Danger);

      const cancelButton = new ButtonBuilder()
        .setCustomId('cancel_delete')
        .setLabel('‚ùå Cancelar')
        .setStyle(ButtonStyle.Secondary);

      const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

      await interaction.editReply({
        content: `‚ö†Ô∏è Se encontraron **${messageCount}** mensaje(s) de ${userDisplayName}.\n¬øEst√°s seguro que deseas borrarlos? Tendr√°s ${UNDO_TIMEOUT_MINUTES} minutos para deshacerlo.`,
        components: [row]
      });

      const filter = i => (i.customId === 'confirm_delete' || i.customId === 'cancel_delete') && i.user.id === interaction.user.id;

      try {
        // Obtener el mensaje de respuesta despu√©s de editReply
        const replyMessage = await interaction.fetchReply();
        try {
          const buttonInteraction = await replyMessage.awaitMessageComponent({ filter, time: 30000 });

          if (buttonInteraction.customId === 'cancel_delete') {
            await buttonInteraction.update({ content: '‚ùå Operaci√≥n cancelada.', components: [] });
            channelLocks.delete(interaction.channel.id);
            return;
          }
        } catch (error) {
          if (error.message && (error.message.includes('time') || error.message.includes('expired'))) {
            await interaction.editReply({
              content: MESSAGES.GENERIC.TIMEOUT_DELETE(30),
              components: []
            });
          } else {
            await interaction.editReply({
              content: `‚ùå Ocurri√≥ un error: ${error.message || 'Error desconocido'}. Por favor, intenta de nuevo.`,
              components: []
            });
          }
          channelLocks.delete(interaction.channel.id);
          return;
        }

        await buttonInteraction.update({ content: `üóëÔ∏è Borrando mensajes de ${userDisplayName}...`, components: [] });

        // Borrar mensajes (l√≥gica similar al comando !)
        const savedMessages = [];
        let totalDeleted = 0;
        fetchMore = true;
        lastMessageId = null;

        while (fetchMore) {
          const fetchOptions = { limit: 100 };
          if (lastMessageId) fetchOptions.before = lastMessageId;

          const fetchedMessages = await interaction.channel.messages.fetch(fetchOptions);
          if (fetchedMessages.size === 0) {
            fetchMore = false;
            break;
          }

          const targetMessages = fetchedMessages.filter(msg => msg.author.id === targetUserId);

          if (targetMessages.size > 0) {
            for (const [, msg] of targetMessages) {
              // Obtener el tag del autor (puede ser null si el usuario fue eliminado)
              const authorId = msg.author ? msg.author.id : targetUserId;
              const authorTag = msg.author ? msg.author.tag : `Usuario eliminado (${authorId})`;
              const authorAvatarURL = msg.author ? msg.author.displayAvatarURL() : null;
              
              savedMessages.push({
                content: msg.content,
                authorId: authorId,
                authorTag: authorTag,
                authorAvatarURL: authorAvatarURL,
                timestamp: msg.createdTimestamp,
                attachments: msg.attachments.map(att => ({ url: att.url, name: att.name })),
                embeds: msg.embeds
              });
            }

            const recentMessages = targetMessages.filter(msg => Date.now() - msg.createdTimestamp < 14 * 24 * 60 * 60 * 1000);
            if (recentMessages.size > 0) {
              if (recentMessages.size === 1) {
                await recentMessages.first().delete();
                totalDeleted += 1;
              } else {
                const deleted = await interaction.channel.bulkDelete(recentMessages, true);
                totalDeleted += deleted.size;
              }
            }

            const oldMessages = targetMessages.filter(msg => Date.now() - msg.createdTimestamp >= 14 * 24 * 60 * 60 * 1000);
            for (const [, oldMsg] of oldMessages) {
              try {
                await oldMsg.delete();
                totalDeleted += 1;
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (error) {
                console.error(`Error borrando mensaje antiguo ${oldMsg.id}:`, error.message);
              }
            }
          }

          lastMessageId = fetchedMessages.last()?.id;
          if (fetchedMessages.size < 100 || totalDeleted >= 500) {
            fetchMore = false;
          }
        }

        // Guardar en cache
        const existingEntry = deletedMessagesCache.get(interaction.channel.id);
        if (existingEntry && existingEntry.timeoutId) {
          clearTimeout(existingEntry.timeoutId);
        }

        const timeoutId = setTimeout(() => {
          deletedMessagesCache.delete(interaction.channel.id);
        }, UNDO_TIMEOUT_MINUTES * 60 * 1000);

        deletedMessagesCache.set(interaction.channel.id, {
          messages: savedMessages,
          deletedBy: interaction.user.id,
          targetUser: userDisplayName,
          timestamp: Date.now(),
          timeoutId: timeoutId
        });

        await buttonInteraction.editReply({
          content: `‚úÖ Se borraron **${totalDeleted}** mensaje(s) de ${userDisplayName}\nüí° Usa \`/deshacerborrado\` en los pr√≥ximos ${UNDO_TIMEOUT_MINUTES} minutos para restaurarlos.`,
          components: []
        });

        console.log(`‚úì ${interaction.user.tag} borr√≥ ${totalDeleted} mensajes de ${userDisplayName} en #${interaction.channel.name} (slash)`);
        channelLocks.delete(interaction.channel.id);

      } catch (error) {
        if (error.message && error.message.includes('time')) {
          await interaction.editReply({ content: '‚è±Ô∏è Se agot√≥ el tiempo de espera. Operaci√≥n cancelada.', components: [] });
          channelLocks.delete(interaction.channel.id);
        } else {
          throw error;
        }
      }
    }

    // /deshacerborrado
    else if (commandName === 'deshacerborrado') {
      if (!interaction.memberPermissions.has(PermissionFlagsBits.ManageMessages)) {
        return interaction.reply({ content: '‚ùå No tienes permisos para usar este comando. Necesitas el permiso "Administrar Mensajes".', flags: MessageFlags.Ephemeral });
      }

      if (!interaction.guild.members.me.permissions.has(PermissionFlagsBits.ManageWebhooks)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para restaurar mensajes. Por favor otorga el permiso "Administrar Webhooks" al bot.', flags: MessageFlags.Ephemeral });
      }

      const entry = deletedMessagesCache.get(interaction.channel.id);
      if (!entry) {
        return interaction.reply({ content: `‚ùå No hay mensajes borrados para restaurar en este canal (o ya pasaron ${UNDO_TIMEOUT_MINUTES} minutos).`, flags: MessageFlags.Ephemeral });
      }

      await interaction.deferReply();
      await interaction.editReply(`üîÑ Restaurando ${entry.messages.length} mensajes de ${entry.targetUser}...`);

      const webhooks = await interaction.channel.fetchWebhooks();
      let webhook = webhooks.find(wh => wh.owner.id === client.user.id);

      if (!webhook) {
        webhook = await interaction.channel.createWebhook({
          name: 'Restaurador de Mensajes',
          reason: 'Webhook para restaurar mensajes borrados'
        });
      }

      const sortedMessages = entry.messages.sort((a, b) => a.timestamp - b.timestamp);
      let restored = 0;

      for (const msgData of sortedMessages) {
        try {
          const webhookOptions = {
            content: msgData.content || null,
            username: msgData.authorTag,
            avatarURL: msgData.authorAvatarURL,
            embeds: msgData.embeds
          };

          if (msgData.attachments && msgData.attachments.length > 0) {
            webhookOptions.files = msgData.attachments.map(att => att.url);
          }

          await webhook.send(webhookOptions);
          restored++;
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.error('Error restaurando mensaje:', error.message);
        }
      }

      if (entry.timeoutId) {
        clearTimeout(entry.timeoutId);
      }
      deletedMessagesCache.delete(interaction.channel.id);

      await interaction.editReply(`‚úÖ Se restauraron **${restored}** de **${entry.messages.length}** mensajes.`);
      console.log(`‚úì ${interaction.user.tag} restaur√≥ ${restored} mensajes en #${interaction.channel.name} (slash)`);
    }

    // /hablar
    else if (commandName === 'hablar') {
      const textToSpeak = interaction.options.getString('texto');
      const userVoiceChannel = interaction.member.voice.channel;

      if (!userVoiceChannel) {
        return interaction.reply({ content: '‚ùå Debes estar en un canal de voz para usar este comando.', flags: MessageFlags.Ephemeral });
      }

      const permissions = userVoiceChannel.permissionsFor(interaction.guild.members.me);
      if (!permissions.has(PermissionFlagsBits.Connect)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para conectarme a tu canal de voz. Por favor otorga el permiso "Conectar".', flags: MessageFlags.Ephemeral });
      }

      if (!permissions.has(PermissionFlagsBits.Speak)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para hablar en tu canal de voz. Por favor otorga el permiso "Hablar".', flags: MessageFlags.Ephemeral });
      }

      const guildId = interaction.guild.id;
      await interaction.deferReply();

      if (!isConnected(guildId)) {
        await connectToVoiceChannel(userVoiceChannel);
        // Guardar el canal de texto donde se ejecut√≥ el comando
        setVoiceChannelTextChannel(guildId, userVoiceChannel, interaction.channel.id);
        await interaction.editReply(`‚úÖ Conectado a **${userVoiceChannel.name}**`);
      }

      const userName = interaction.member.displayName || interaction.user.username;
      const fullMessage = `${userName} dice: ${textToSpeak}`;

      await speakText(guildId, fullMessage, 'es');
      await interaction.editReply(`üîä Reproduciendo: "${textToSpeak}"`);
      console.log(`‚úì ${interaction.user.tag} us√≥ TTS: "${fullMessage}" (slash)`);
    }

    // /join
    else if (commandName === 'join') {
      const userVoiceChannel = interaction.member.voice.channel;

      if (!userVoiceChannel) {
        return interaction.reply({ content: '‚ùå Debes estar en un canal de voz para usar este comando.', flags: MessageFlags.Ephemeral });
      }

      const guildId = interaction.guild.id;

      if (isConnected(guildId)) {
        return interaction.reply({ content: '‚úÖ Ya estoy conectado a un canal de voz. Usa `/salir` para desconectarme primero.', flags: MessageFlags.Ephemeral });
      }

      const permissions = userVoiceChannel.permissionsFor(interaction.guild.members.me);
      if (!permissions.has(PermissionFlagsBits.Connect)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para conectarme a tu canal de voz. Por favor otorga el permiso "Conectar".', flags: MessageFlags.Ephemeral });
      }

      if (!permissions.has(PermissionFlagsBits.Speak)) {
        return interaction.reply({ content: '‚ùå No tengo permisos para hablar en tu canal de voz. Por favor otorga el permiso "Hablar".', flags: MessageFlags.Ephemeral });
      }

      await interaction.deferReply();
      await connectToVoiceChannel(userVoiceChannel);
      // Guardar el canal de texto donde se ejecut√≥ el comando (chat de voz)
      setVoiceChannelTextChannel(guildId, userVoiceChannel, interaction.channel.id);
      await interaction.editReply(`‚úÖ Conectado a **${userVoiceChannel.name}**\nüí¨ Ahora leer√© autom√°ticamente los mensajes que escriban los usuarios en este canal de texto (chat de voz).`);
      console.log(`‚úì ${interaction.user.tag} conect√≥ el bot a ${userVoiceChannel.name} (modo lectura autom√°tica, slash, canal de texto: ${interaction.channel.name})`);
    }

    // /salir
    else if (commandName === 'salir') {
      const guildId = interaction.guild.id;

      if (!isConnected(guildId)) {
        return interaction.reply({ content: '‚ùå No estoy conectado a ning√∫n canal de voz.', flags: MessageFlags.Ephemeral });
      }

      disconnectFromVoiceChannel(guildId);
      lastVoiceSpeakers.delete(guildId); // Limpiar registro de √∫ltimos hablantes
      await interaction.reply('üëã Me he desconectado del canal de voz.');
      console.log(`‚úì ${interaction.user.tag} desconect√≥ el bot del canal de voz (slash)`);
    }

    // ==================== FASE 3: SISTEMA DE HONOR Y RANGOS ====================

    // /honor - Mostrar honor actual y progreso
    else if (commandName === 'honor') {
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      // Obtener datos del usuario
      const userData = dataManager.getUser(userId, guildId);
      const currentHonor = userData.honor;
      const currentRank = userData.rank;

      // Calcular el siguiente rango y honor necesario
      let nextRank = null;
      let honorNeeded = 0;
      let progressPercent = 0;
      let rankThresholds = {
        'Ronin': { next: 'Samurai', threshold: CONSTANTS.HONOR.RANK_THRESHOLDS.SAMURAI },
        'Samurai': { next: 'Daimyo', threshold: CONSTANTS.HONOR.RANK_THRESHOLDS.DAIMYO },
        'Daimyo': { next: 'Shogun', threshold: CONSTANTS.HONOR.RANK_THRESHOLDS.SHOGUN },
        'Shogun': { next: null, threshold: null }
      };

      if (currentRank !== 'Shogun') {
        nextRank = rankThresholds[currentRank].next;
        const threshold = rankThresholds[currentRank].threshold;
        honorNeeded = threshold - currentHonor;

        // Calcular porcentaje de progreso
        if (currentRank === 'Ronin') {
          progressPercent = Math.min(100, (currentHonor / CONSTANTS.HONOR.RANK_THRESHOLDS.SAMURAI) * 100);
        } else if (currentRank === 'Samurai') {
          const start = CONSTANTS.HONOR.RANK_THRESHOLDS.SAMURAI;
          const end = CONSTANTS.HONOR.RANK_THRESHOLDS.DAIMYO;
          progressPercent = Math.min(100, ((currentHonor - start) / (end - start)) * 100);
        } else if (currentRank === 'Daimyo') {
          const start = CONSTANTS.HONOR.RANK_THRESHOLDS.DAIMYO;
          const end = CONSTANTS.HONOR.RANK_THRESHOLDS.SHOGUN;
          progressPercent = Math.min(100, ((currentHonor - start) / (end - start)) * 100);
        }
      } else {
        // Ya es Shogun (rango m√°ximo)
        progressPercent = 100;
      }

      // Crear barra de progreso visual
      const barLength = CONSTANTS.LEADERBOARDS.PROGRESS_BAR_LENGTH;
      const filledBars = Math.floor((progressPercent / 100) * barLength);
      const emptyBars = barLength - filledBars;
      const progressBar = '‚ñà'.repeat(filledBars) + '‚ñë'.repeat(emptyBars);

      // Crear embed de honor
      const embed = new EmbedBuilder()
        .setColor(COLORS.HONOR)
        .setTitle(`${EMOJIS.HONOR} Honor de ${interaction.member.displayName || interaction.user.username}`)
        .setDescription(`Tu camino samurai en **${interaction.guild.name}**`)
        .addFields(
          {
            name: `${EMOJIS.STAR} Honor Actual`,
            value: `**${currentHonor}** puntos`,
            inline: true
          },
          {
            name: `${getRankEmoji(currentRank)} Rango`,
            value: `**${currentRank}**`,
            inline: true
          },
          {
            name: '\u200B',
            value: '\u200B',
            inline: true
          }
        )
        .setThumbnail(interaction.user.displayAvatarURL())
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      // A√±adir campo de progreso si no es Shogun
      if (currentRank !== 'Shogun') {
        embed.addFields({
          name: `${EMOJIS.LOADING} Progreso hacia ${nextRank}`,
          value: `${progressBar} ${progressPercent.toFixed(1)}%\n${EMOJIS.KATANA} Faltan **${honorNeeded}** puntos de honor`,
          inline: false
        });
      } else {
        embed.addFields({
          name: `${EMOJIS.CROWN} Rango M√°ximo Alcanzado`,
          value: `${EMOJIS.TROPHY} Has alcanzado el rango m√°s alto del dojo. ¬°Tu leyenda es eterna!`,
          inline: false
        });
      }

      // A√±adir informaci√≥n del clan si pertenece a uno
      if (userData.clanId) {
        const userClan = dataManager.getClan(userData.clanId);
        if (userClan) {
          const clanLevel = dataManager.getClanLevel(userClan.totalHonor);
          const isLeader = userClan.leaderId === userId;
          const leaderBadge = isLeader ? `${EMOJIS.LEADER} ` : '';
          embed.addFields({
            name: `${EMOJIS.CLAN} Clan`,
            value: `${leaderBadge}**[${userClan.tag}] ${userClan.name}**\n${EMOJIS.CLAN_LEVEL} Nivel ${clanLevel.level} | ${EMOJIS.MEMBERS} ${userClan.members.length}/${clanLevel.maxMembers} miembros`,
            inline: false
          });
        }
      }

      // A√±adir estad√≠sticas
      embed.addFields({
        name: `${EMOJIS.SCROLL} Estad√≠sticas`,
        value: `${EMOJIS.MESSAGE} Mensajes: **${userData.stats?.messagesCount || 0}**\n${EMOJIS.VOICE} Minutos en voz: **${userData.stats?.voiceMinutes || 0}**\n${EMOJIS.DUEL} Duelos ganados: **${userData.stats?.duelsWon || 0}**`,
        inline: false
      });

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} ${interaction.user.tag} consult√≥ su honor (${currentHonor} honor, ${currentRank})`);
    }

    // /rango - Mostrar rango actual y beneficios
    else if (commandName === 'rango') {
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      const userData = dataManager.getUser(userId, guildId);
      const currentRank = userData.rank;
      const currentHonor = userData.honor;

      // Definir informaci√≥n de rangos
      const rankInfo = {
        'Ronin': {
          description: 'Un guerrero sin maestro que busca su camino en el dojo.',
          benefits: [
            '‚Ä¢ Acceso a comandos b√°sicos del dojo',
            '‚Ä¢ Ganancia de honor por actividad',
            '‚Ä¢ Participaci√≥n en el ranking'
          ],
          honorRange: '0 - 499',
          nextRank: 'Samurai (500 honor)',
          color: COLORS.RONIN,
          emoji: EMOJIS.RONIN
        },
        'Samurai': {
          description: 'Un guerrero disciplinado que ha demostrado su val√≠a en el dojo.',
          benefits: [
            '‚Ä¢ Todos los beneficios de Ronin',
            '‚Ä¢ Mayor ganancia de honor diaria',
            '‚Ä¢ Acceso a comandos de clan',
            '‚Ä¢ Emblema especial en el ranking'
          ],
          honorRange: '500 - 1,999',
          nextRank: 'Daimyo (2,000 honor)',
          color: COLORS.SAMURAI,
          emoji: EMOJIS.SAMURAI
        },
        'Daimyo': {
          description: 'Un se√±or feudal respetado, l√≠der entre los guerreros del dojo.',
          benefits: [
            '‚Ä¢ Todos los beneficios de Samurai',
            '‚Ä¢ Recompensas diarias mejoradas',
            '‚Ä¢ Capacidad de crear clanes',
            '‚Ä¢ Prioridad en eventos del dojo',
            '‚Ä¢ Emblema dorado en el ranking'
          ],
          honorRange: '2,000 - 4,999',
          nextRank: 'Shogun (5,000 honor)',
          color: COLORS.DAIMYO,
          emoji: EMOJIS.DAIMYO
        },
        'Shogun': {
          description: 'El comandante supremo, maestro absoluto del arte samurai.',
          benefits: [
            '‚Ä¢ Todos los beneficios de Daimyo',
            '‚Ä¢ M√°ximas recompensas diarias',
            '‚Ä¢ Acceso a comandos exclusivos',
            '‚Ä¢ Emblema legendario en el ranking',
            '‚Ä¢ Reconocimiento eterno en el dojo',
            '‚Ä¢ Rol especial (si configurado)'
          ],
          honorRange: '5,000+',
          nextRank: 'Rango M√°ximo',
          color: COLORS.SHOGUN,
          emoji: EMOJIS.SHOGUN
        }
      };

      const info = rankInfo[currentRank];

      const embed = new EmbedBuilder()
        .setColor(info.color)
        .setTitle(`${info.emoji} ${currentRank}`)
        .setDescription(info.description)
        .addFields(
          {
            name: `${EMOJIS.SCROLL} Rango de Honor`,
            value: info.honorRange,
            inline: true
          },
          {
            name: `${EMOJIS.HONOR} Tu Honor`,
            value: `${currentHonor} puntos`,
            inline: true
          },
          {
            name: '\u200B',
            value: '\u200B',
            inline: true
          },
          {
            name: `${EMOJIS.GIFT} Beneficios del Rango`,
            value: info.benefits.join('\n'),
            inline: false
          },
          {
            name: `${EMOJIS.KATANA} Pr√≥ximo Rango`,
            value: info.nextRank,
            inline: false
          }
        )
        .setThumbnail(interaction.user.displayAvatarURL())
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} ${interaction.user.tag} consult√≥ su rango (${currentRank})`);
    }

    // /top - Leaderboard de honor
    else if (commandName === 'top') {
      const guildId = interaction.guild.id;

      await interaction.deferReply();

      // Obtener todos los usuarios del servidor
      const guildUsers = dataManager.getGuildUsers(guildId);

      if (guildUsers.length === 0) {
        return interaction.editReply(`${EMOJIS.INFO} A√∫n no hay guerreros registrados en el dojo. ¬°Usa comandos para ganar honor!`);
      }

      // Ordenar por honor (de mayor a menor)
      const sortedUsers = guildUsers.sort((a, b) => b.honor - a.honor);

      // Tomar top 10
      const top10 = sortedUsers.slice(0, CONSTANTS.LEADERBOARDS.TOP_DISPLAY_COUNT);

      // Encontrar posici√≥n del usuario que ejecut√≥ el comando
      const userIndex = sortedUsers.findIndex(u => u.userId === interaction.user.id);
      const userPosition = userIndex >= 0 ? userIndex + 1 : null;
      const userHonor = userIndex >= 0 ? sortedUsers[userIndex].honor : 0;

      // Obtener displayNames del servidor (nombres modificados en el canal)
      const userIds = top10.map(u => u.userId);
      const displayNameMap = await fetchDisplayNamesBatch(interaction.guild, userIds);

      // Crear descripci√≥n del leaderboard
      let description = '';

      for (let i = 0; i < top10.length; i++) {
        const user = top10[i];
        const position = i + 1;

        // Emojis de medalla para top 3
        let positionEmoji = '';
        if (position === 1) positionEmoji = EMOJIS.FIRST;
        else if (position === 2) positionEmoji = EMOJIS.SECOND;
        else if (position === 3) positionEmoji = EMOJIS.THIRD;
        else positionEmoji = `\`${position}.\``;

        // Emoji de rango
        const rankEmoji = getRankEmoji(user.rank);

        // Obtener displayName del servidor (nombre modificado en el canal)
        const userName = displayNameMap.get(user.userId) || 'Usuario Desconocido';

        // Resaltar si es el usuario que ejecut√≥ el comando
        const isCurrentUser = user.userId === interaction.user.id;
        const highlight = isCurrentUser ? '**‚û§ ' : '';
        const highlightEnd = isCurrentUser ? '**' : '';

        description += `${positionEmoji} ${highlight}${rankEmoji} ${userName} - ${user.honor} honor${highlightEnd}\n`;
      }

      const embed = new EmbedBuilder()
        .setColor(COLORS.GOLD)
        .setTitle(`${EMOJIS.TROPHY} Ranking de Honor - ${interaction.guild.name}`)
        .setDescription(description)
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      // A√±adir posici√≥n del usuario si no est√° en el top 10
      if (userPosition !== null && userPosition > 10) {
        embed.addFields({
          name: `${EMOJIS.INFO} Tu Posici√≥n`,
          value: `**#${userPosition}** - ${userHonor} honor`,
          inline: false
        });
      } else if (userPosition === null) {
        embed.addFields({
          name: `${EMOJIS.INFO} Tu Posici√≥n`,
          value: 'No registrado - ¬°Usa comandos para ganar honor!',
          inline: false
        });
      }

      await interaction.editReply({ embeds: [embed] });
      console.log(`${EMOJIS.SUCCESS} ${interaction.user.tag} consult√≥ el ranking de honor`);
    }

    // ==================== FASE 4: SISTEMA DE ECONOM√çA Y RECOMPENSAS DIARIAS ====================

    // /daily - Reclamar recompensa diaria
    else if (commandName === 'daily') {
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      const userData = dataManager.getUser(userId, guildId);
      const now = Date.now();

      // Verificar si ya reclam√≥ hoy (24 horas)
      if (userData.lastDailyClaim) {
        const timeSinceLastClaim = now - userData.lastDailyClaim;
        const twentyFourHours = 24 * 60 * 60 * 1000;

        if (timeSinceLastClaim < twentyFourHours) {
          // A√∫n no han pasado 24 horas
          const timeLeft = twentyFourHours - timeSinceLastClaim;
          const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
          const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));

          let timeLeftString = '';
          if (hoursLeft > 0) {
            timeLeftString = `${hoursLeft} hora${hoursLeft > 1 ? 's' : ''}`;
            if (minutesLeft > 0) {
              timeLeftString += ` y ${minutesLeft} minuto${minutesLeft > 1 ? 's' : ''}`;
            }
          } else {
            timeLeftString = `${minutesLeft} minuto${minutesLeft > 1 ? 's' : ''}`;
          }

          return interaction.reply({
            content: MESSAGES.ECONOMY.DAILY_ALREADY_CLAIMED(timeLeftString),
            flags: MessageFlags.Ephemeral
          });
        }
      }

      // Calcular streak
      let newStreak = 1;
      if (userData.lastDailyClaim) {
        const timeSinceLastClaim = now - userData.lastDailyClaim;
        const fortyEightHours = 48 * 60 * 60 * 1000;

        // Si reclam√≥ dentro de las √∫ltimas 48 horas, continuar streak
        if (timeSinceLastClaim < fortyEightHours) {
          newStreak = (userData.dailyStreak || 0) + 1;
        }
        // Si pasaron m√°s de 48 horas, perdi√≥ el streak
      }

      // Calcular recompensa usando CONSTANTS
      const baseReward = CONSTANTS.ECONOMY.DAILY.BASE_REWARD;
      const rankMultiplier = CONSTANTS.getRankMultiplier(userData.rank);
      const streakBonus = CONSTANTS.getStreakBonus(newStreak);

      const totalKoku = Math.floor(baseReward * rankMultiplier * (1 + streakBonus));

      // Actualizar datos del usuario
      userData.koku = (userData.koku || 0) + totalKoku;
      userData.lastDailyClaim = now;
      userData.dailyStreak = newStreak;
      dataManager.dataModified.users = true;

      // Crear embed de recompensa
      const embed = new EmbedBuilder()
        .setColor(COLORS.KOKU)
        .setTitle(`${EMOJIS.DAILY} Recompensa Diaria Reclamada`)
        .setDescription(`¬°Has reclamado tu recompensa diaria, ${interaction.member?.displayName || interaction.user.username}!`)
        .addFields(
          {
            name: `${EMOJIS.KOKU} Koku Ganado`,
            value: `**+${totalKoku}** koku`,
            inline: true
          },
          {
            name: `${EMOJIS.FIRE} Racha`,
            value: `**${newStreak}** d√≠a${newStreak > 1 ? 's' : ''}`,
            inline: true
          },
          {
            name: `${EMOJIS.BANK} Balance Total`,
            value: `**${userData.koku}** koku`,
            inline: true
          }
        )
        .addFields({
          name: `${EMOJIS.INFO} Detalles`,
          value: `${EMOJIS.COIN} Base: ${baseReward} koku\n${getRankEmoji(userData.rank)} Multiplicador de rango (${userData.rank}): x${rankMultiplier}\n${EMOJIS.STREAK} Bonus de racha: +${(streakBonus * 100).toFixed(0)}%`,
          inline: false
        })
        .setFooter({ text: 'üí° Reclama todos los d√≠as para mantener tu racha activa' })
        .setTimestamp();

      // Si es un nuevo milestone de streak, agregar mensaje especial
      if (newStreak === 7 || newStreak === 14 || newStreak === 30 || newStreak === 90) {
        embed.addFields({
          name: `${EMOJIS.TROPHY} ¬°Milestone Alcanzado!`,
          value: `${EMOJIS.FIRE} Has alcanzado una racha de **${newStreak} d√≠as**. ¬°Sigue as√≠, guerrero!`,
          inline: false
        });
      }

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.DAILY} ${interaction.user.tag} reclam√≥ recompensa diaria: +${totalKoku} koku (streak: ${newStreak})`);
    }

    // /balance o /bal - Mostrar balance
    else if (commandName === 'balance' || commandName === 'bal') {
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      const userData = dataManager.getUser(userId, guildId);

      // Calcular tiempo hasta pr√≥xima recompensa diaria
      let nextDailyInfo = 'Disponible ahora';
      if (userData.lastDailyClaim) {
        const timeSinceLastClaim = Date.now() - userData.lastDailyClaim;
        const twentyFourHours = 24 * 60 * 60 * 1000;

        if (timeSinceLastClaim < twentyFourHours) {
          const timeLeft = twentyFourHours - timeSinceLastClaim;
          const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
          const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));

          if (hoursLeft > 0) {
            nextDailyInfo = `En ${hoursLeft}h ${minutesLeft}m`;
          } else {
            nextDailyInfo = `En ${minutesLeft}m`;
          }
        }
      }

      const embed = new EmbedBuilder()
        .setColor(COLORS.KOKU)
        .setTitle(`${EMOJIS.BANK} Balance de ${interaction.member?.displayName || interaction.user.username}`)
        .setDescription(`Tu riqueza en **${interaction.guild.name}**`)
        .addFields(
          {
            name: `${EMOJIS.KOKU} Koku`,
            value: `**${userData.koku || 0}** koku`,
            inline: true
          },
          {
            name: `${EMOJIS.HONOR} Honor`,
            value: `**${userData.honor}** puntos`,
            inline: true
          },
          {
            name: `${getRankEmoji(userData.rank)} Rango`,
            value: `**${userData.rank}**`,
            inline: true
          },
          {
            name: `${EMOJIS.FIRE} Racha Diaria`,
            value: `**${userData.dailyStreak || 0}** d√≠a${userData.dailyStreak > 1 ? 's' : ''}`,
            inline: true
          },
          {
            name: `${EMOJIS.CALENDAR} Pr√≥ximo Daily`,
            value: nextDailyInfo,
            inline: true
          },
          {
            name: '\u200B',
            value: '\u200B',
            inline: true
          }
        )
        .setThumbnail(interaction.user.displayAvatarURL())
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.BANK} ${interaction.user.tag} consult√≥ su balance (${userData.koku} koku, ${userData.honor} honor)`);
    }

    // /pay o /pagar - Transferir koku
    else if (commandName === 'pay' || commandName === 'pagar') {
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;
      const targetUser = interaction.options.getUser('usuario');
      const amount = interaction.options.getInteger('cantidad');

      // Validaciones
      if (targetUser.id === userId) {
        return interaction.reply({
          content: MESSAGES.ECONOMY.CANNOT_PAY_SELF,
          flags: MessageFlags.Ephemeral
        });
      }

      if (targetUser.bot) {
        return interaction.reply({
          content: `${EMOJIS.ERROR} No puedes transferir koku a un bot, guerrero.`,
          flags: MessageFlags.Ephemeral
        });
      }

      if (amount < 10 || amount > 10000) {
        return interaction.reply({
          content: MESSAGES.ECONOMY.INVALID_AMOUNT,
          flags: MessageFlags.Ephemeral
        });
      }

      // Obtener datos de ambos usuarios
      const senderData = dataManager.getUser(userId, guildId);
      const recipientData = dataManager.getUser(targetUser.id, guildId);

      // Verificar saldo suficiente
      if ((senderData.koku || 0) < amount) {
        return interaction.reply({
          content: MESSAGES.ECONOMY.INSUFFICIENT_KOKU(amount, senderData.koku || 0),
          flags: MessageFlags.Ephemeral
        });
      }

      // Crear botones de confirmaci√≥n
      const confirmButton = new ButtonBuilder()
        .setCustomId('confirm_payment')
        .setLabel('‚úÖ Confirmar')
        .setStyle(ButtonStyle.Success);

      const cancelButton = new ButtonBuilder()
        .setCustomId('cancel_payment')
        .setLabel('‚ùå Cancelar')
        .setStyle(ButtonStyle.Secondary);

      const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

      // Obtener displayNames
      const targetMember = await interaction.guild.members.fetch(targetUser.id).catch(() => null);
      const targetDisplayName = targetMember?.displayName || targetUser.username;
      const senderDisplayName = interaction.member?.displayName || interaction.user.username;

      await interaction.reply({
        content: `${EMOJIS.WARNING} ¬øEst√°s seguro de transferir **${amount} koku** a **${targetDisplayName}**?`,
        components: [row],
        flags: MessageFlags.Ephemeral
      });

      // Esperar respuesta del bot√≥n
      const filter = i => (i.customId === 'confirm_payment' || i.customId === 'cancel_payment') && i.user.id === userId;

      try {
        const replyMessage = await interaction.fetchReply();
        const buttonInteraction = await replyMessage.awaitMessageComponent({ filter, time: 30000 });

        if (buttonInteraction.customId === 'cancel_payment') {
          await buttonInteraction.update({
            content: MESSAGES.GENERIC.CANCELLED,
            components: []
          });
          return;
        }

        // Confirmar transferencia
        senderData.koku = (senderData.koku || 0) - amount;
        recipientData.koku = (recipientData.koku || 0) + amount;
        dataManager.dataModified.users = true;

        await buttonInteraction.update({
          content: MESSAGES.ECONOMY.PAYMENT_SUCCESS(amount, targetDisplayName),
          components: []
        });

        // Enviar notificaci√≥n al receptor (intentar DM, sino en el canal)
        try {
          await targetUser.send(`${MESSAGES.ECONOMY.PAYMENT_RECEIVED(amount, senderDisplayName)}\n${EMOJIS.INFO} En el servidor: **${interaction.guild.name}**`);
        } catch (error) {
          // Si no se puede enviar DM, enviar en el canal
          await interaction.followUp({
            content: `${targetUser}, ${MESSAGES.ECONOMY.PAYMENT_RECEIVED(amount, senderDisplayName)}`,
          });
        }

        console.log(`${EMOJIS.PAYMENT} ${interaction.user.tag} transfiri√≥ ${amount} koku a ${targetUser.tag}`);

      } catch (error) {
        if (error.message && (error.message.includes('time') || error.message.includes('expired'))) {
          await interaction.editReply({
            content: MESSAGES.GENERIC.TIMEOUT_PAYMENT(30),
            components: []
          });
        } else {
          await interaction.editReply({
            content: `‚ùå Ocurri√≥ un error al procesar la transferencia: ${error.message || 'Error desconocido'}. Por favor, intenta de nuevo.`,
            components: []
          });
        }
      }
    }

    // /leaderboard o /lb - Ranking con pesta√±as
    else if (commandName === 'leaderboard' || commandName === 'lb') {
      const guildId = interaction.guild.id;

      await interaction.deferReply();

      // Obtener todos los usuarios del servidor
      const guildUsers = dataManager.getGuildUsers(guildId);

      if (guildUsers.length === 0) {
        return interaction.editReply(`${EMOJIS.INFO} A√∫n no hay guerreros registrados en el dojo. ¬°Usa comandos para ganar honor!`);
      }

      // Crear botones para cambiar entre rankings
      const honorButton = new ButtonBuilder()
        .setCustomId('lb_honor')
        .setLabel('Honor')
        .setEmoji(EMOJIS.TROPHY)
        .setStyle(ButtonStyle.Primary);

      const kokuButton = new ButtonBuilder()
        .setCustomId('lb_koku')
        .setLabel('Koku')
        .setEmoji(EMOJIS.KOKU)
        .setStyle(ButtonStyle.Success);

      const streakButton = new ButtonBuilder()
        .setCustomId('lb_streak')
        .setLabel('Rachas')
        .setEmoji(EMOJIS.FIRE)
        .setStyle(ButtonStyle.Danger);

      const row = new ActionRowBuilder().addComponents(honorButton, kokuButton, streakButton);

      // Funci√≥n para generar embed de ranking
      const generateLeaderboardEmbed = async (type) => {
        let sortedUsers, title, emoji, valueKey;

        if (type === 'honor') {
          sortedUsers = guildUsers.sort((a, b) => b.honor - a.honor);
          title = MESSAGES.ECONOMY.LEADERBOARD_HONOR;
          emoji = EMOJIS.HONOR;
          valueKey = 'honor';
        } else if (type === 'koku') {
          sortedUsers = guildUsers.sort((a, b) => (b.koku || 0) - (a.koku || 0));
          title = MESSAGES.ECONOMY.LEADERBOARD_KOKU;
          emoji = EMOJIS.KOKU;
          valueKey = 'koku';
        } else if (type === 'streak') {
          sortedUsers = guildUsers.sort((a, b) => (b.dailyStreak || 0) - (a.dailyStreak || 0));
          title = MESSAGES.ECONOMY.LEADERBOARD_STREAK;
          emoji = EMOJIS.FIRE;
          valueKey = 'dailyStreak';
        }

        const top10 = sortedUsers.slice(0, CONSTANTS.LEADERBOARDS.TOP_DISPLAY_COUNT);
        const userIndex = sortedUsers.findIndex(u => u.userId === interaction.user.id);
        const userPosition = userIndex >= 0 ? userIndex + 1 : null;
        const userValue = userIndex >= 0 ? (sortedUsers[userIndex][valueKey] || 0) : 0;

        // Obtener displayNames del servidor (nombres modificados en el canal)
        const userIds = top10.map(u => u.userId);
        const displayNameMap = await fetchDisplayNamesBatch(interaction.guild, userIds);

        let description = '';

        for (let i = 0; i < top10.length; i++) {
          const user = top10[i];
          const position = i + 1;

          let positionEmoji = '';
          if (position === 1) positionEmoji = EMOJIS.FIRST;
          else if (position === 2) positionEmoji = EMOJIS.SECOND;
          else if (position === 3) positionEmoji = EMOJIS.THIRD;
          else positionEmoji = `\`${position}.\``;

          const rankEmoji = getRankEmoji(user.rank);

          // Obtener displayName del servidor (nombre modificado en el canal)
          const userName = displayNameMap.get(user.userId) || 'Usuario Desconocido';

          const isCurrentUser = user.userId === interaction.user.id;
          const highlight = isCurrentUser ? '**‚û§ ' : '';
          const highlightEnd = isCurrentUser ? '**' : '';

          const value = user[valueKey] || 0;
          const valueLabel = type === 'honor' ? 'honor' : type === 'koku' ? 'koku' : 'd√≠as';

          description += `${positionEmoji} ${highlight}${rankEmoji} ${userName} - ${value} ${valueLabel}${highlightEnd}\n`;
        }

        const embed = new EmbedBuilder()
          .setColor(type === 'honor' ? COLORS.GOLD : type === 'koku' ? COLORS.KOKU : COLORS.ERROR)
          .setTitle(`${title} - ${interaction.guild.name}`)
          .setDescription(description)
          .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
          .setTimestamp();

        if (userPosition !== null && userPosition > 10) {
          embed.addFields({
            name: `${EMOJIS.INFO} Tu Posici√≥n`,
            value: `**#${userPosition}** - ${userValue} ${type === 'honor' ? 'honor' : type === 'koku' ? 'koku' : 'd√≠as'}`,
            inline: false
          });
        } else if (userPosition === null) {
          embed.addFields({
            name: `${EMOJIS.INFO} Tu Posici√≥n`,
            value: 'No registrado - ¬°Usa comandos para ganar!',
            inline: false
          });
        }

        return embed;
      };

      // Mostrar ranking de honor por defecto
      const initialEmbed = await generateLeaderboardEmbed('honor');
      const response = await interaction.editReply({
        embeds: [initialEmbed],
        components: [row]
      });

      // Collector para los botones
      const collector = response.createMessageComponentCollector({ time: 120000 }); // 2 minutos

      collector.on('collect', async (i) => {
        if (i.user.id !== interaction.user.id) {
          const ownerDisplayName = interaction.member?.displayName || interaction.user.username;
          return i.reply({ content: `${EMOJIS.WARNING} Solo ${ownerDisplayName} puede usar estos botones.`, flags: MessageFlags.Ephemeral });
        }

        let type = 'honor';
        if (i.customId === 'lb_koku') type = 'koku';
        else if (i.customId === 'lb_streak') type = 'streak';

        const newEmbed = await generateLeaderboardEmbed(type);
        await i.update({ embeds: [newEmbed], components: [row] });

        console.log(`${EMOJIS.CHART} ${i.user.tag} cambi√≥ el leaderboard a: ${type}`);
      });

      collector.on('end', async () => {
        try {
          // Deshabilitar botones cuando expire el collector
          const disabledRow = new ActionRowBuilder().addComponents(
            honorButton.setDisabled(true),
            kokuButton.setDisabled(true),
            streakButton.setDisabled(true)
          );
          await interaction.editReply({ components: [disabledRow] });
        } catch (error) {
          // Ignorar errores si el mensaje fue eliminado
        }
      });

      console.log(`${EMOJIS.CHART} ${interaction.user.tag} consult√≥ el leaderboard`);
    }

    // FASE 5: SISTEMA DE CLANES
    // /clan crear - Crear un nuevo clan
    else if (commandName === 'clan') {
      const subcommand = interaction.options.getSubcommand();
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      // /clan crear
      if (subcommand === 'crear') {
        const clanName = interaction.options.getString('nombre').trim();
        const clanTag = interaction.options.getString('tag').trim().toUpperCase();

        // Validar nombre
        if (clanName.length < 3 || clanName.length > 30) {
          return interaction.reply({ content: MESSAGES.CLAN.INVALID_CLAN_NAME, flags: MessageFlags.Ephemeral });
        }

        // Validar tag (solo letras y n√∫meros, 2-5 caracteres)
        if (!/^[A-Z0-9]{2,5}$/.test(clanTag)) {
          return interaction.reply({ content: MESSAGES.CLAN.INVALID_CLAN_TAG, flags: MessageFlags.Ephemeral });
        }

        // Verificar si el usuario puede crear un clan
        const canCreate = dataManager.canCreateClan(userId, guildId);
        if (!canCreate.canCreate) {
          return interaction.reply({ content: canCreate.reason, flags: MessageFlags.Ephemeral });
        }

        // Verificar si el nombre o tag ya existen
        if (dataManager.clanNameOrTagExists(guildId, clanName, clanTag)) {
          return interaction.reply({ content: MESSAGES.CLAN.CLAN_NAME_EXISTS, flags: MessageFlags.Ephemeral });
        }

        await interaction.deferReply();

        // Crear el clan
        const clan = dataManager.createClan(clanName, clanTag, userId, guildId);

        // Deducir el costo de 5000 koku
        const user = dataManager.getUser(userId, guildId);
        user.koku -= 5000;
        user.clanId = clan.clanId;

        // Actualizar stats del clan
        dataManager.updateClanStats(clan.clanId);

        // Guardar datos
        await dataManager.saveUsers();
        await dataManager.saveClans();

        // Crear embed de confirmaci√≥n
        const clanLevel = dataManager.getClanLevel(clan.totalHonor);
        const embed = new EmbedBuilder()
          .setColor(clanLevel.color)
          .setTitle(`${EMOJIS.CASTLE} Clan Fundado`)
          .setDescription(MESSAGES.CLAN.CLAN_CREATED_DETAILS(clanName, clanTag, 5000))
          .addFields(
            { name: `${EMOJIS.CLAN_TAG} Tag`, value: `[${clanTag}]`, inline: true },
            { name: `${EMOJIS.CLAN_LEVEL} Nivel`, value: `${clanLevel.level} - ${clanLevel.name}`, inline: true },
            { name: `${EMOJIS.MEMBERS} Miembros`, value: `1/${clanLevel.maxMembers}`, inline: true },
            { name: `${EMOJIS.HONOR} Honor Total`, value: `${clan.totalHonor.toLocaleString()} puntos`, inline: true },
            { name: `${EMOJIS.KOKU} Tu Balance`, value: `${user.koku.toLocaleString()} koku`, inline: true }
          )
          .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
          .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
        console.log(`${EMOJIS.CLAN} ${interaction.user.tag} cre√≥ el clan "${clanName}" [${clanTag}]`);
      }

      // /clan info
      else if (subcommand === 'info') {
        const clanNameInput = interaction.options.getString('nombre');
        let clan;

        if (clanNameInput) {
          // Buscar clan por nombre o tag
          clan = dataManager.findClanByNameOrTag(guildId, clanNameInput);
          if (!clan) {
            return interaction.reply({ content: MESSAGES.CLAN.CLAN_NOT_FOUND, flags: MessageFlags.Ephemeral });
          }
        } else {
          // Mostrar clan del usuario
          const user = dataManager.getUser(userId, guildId);
          if (!user.clanId) {
            return interaction.reply({ content: MESSAGES.CLAN.NOT_IN_CLAN, flags: MessageFlags.Ephemeral });
          }
          clan = dataManager.getClan(user.clanId);
        }

        await interaction.deferReply();

        // Obtener info del clan
        const clanLevel = dataManager.getClanLevel(clan.totalHonor);
        const leaderMember = await interaction.guild.members.fetch(clan.leaderId).catch(() => null);
        const leaderName = leaderMember ? (leaderMember.displayName || leaderMember.user.username) : 'Usuario desconocido';
        const leaderUser = dataManager.getUser(clan.leaderId, guildId);
        const leaderRankEmoji = EMOJIS[leaderUser.rank.toUpperCase()] || EMOJIS.RONIN;

        // Crear lista de miembros con rangos
        let membersList = '';
        const memberPromises = clan.members.slice(0, 10).map(async (memberId) => {
          const member = await interaction.guild.members.fetch(memberId).catch(() => null);
          const memberUser = dataManager.getUser(memberId, guildId);
          const rankEmoji = EMOJIS[memberUser.rank.toUpperCase()] || EMOJIS.RONIN;
          const isLeader = memberId === clan.leaderId;
          const leaderBadge = isLeader ? `${EMOJIS.LEADER} ` : '';
          const memberDisplayName = member ? (member.displayName || member.user.username) : 'Usuario desconocido';
          return `${leaderBadge}${rankEmoji} ${memberDisplayName} - ${memberUser.honor.toLocaleString()} honor`;
        });

        const membersData = await Promise.all(memberPromises);
        membersList = membersData.join('\n');

        if (clan.members.length > 10) {
          membersList += `\n... y ${clan.members.length - 10} miembros m√°s`;
        }

        // Crear embed
        const createdDate = new Date(clan.createdAt).toLocaleDateString('es-ES');
        const progressToNext = clanLevel.nextLevelHonor
          ? `${clan.totalHonor.toLocaleString()}/${clanLevel.nextLevelHonor.toLocaleString()} (${Math.floor(clan.totalHonor / clanLevel.nextLevelHonor * 100)}%)`
          : 'Nivel M√°ximo';

        const embed = new EmbedBuilder()
          .setColor(clanLevel.color)
          .setTitle(`${EMOJIS.CLAN} ${clan.name} [${clan.tag}]`)
          .setDescription(`${EMOJIS.CLAN_LEVEL} **Nivel ${clanLevel.level}** - ${clanLevel.name}`)
          .addFields(
            { name: `${EMOJIS.LEADER} L√≠der`, value: `${leaderRankEmoji} ${leaderName}`, inline: true },
            { name: `${EMOJIS.MEMBERS} Miembros`, value: `${clan.members.length}/${clanLevel.maxMembers}`, inline: true },
            { name: `${EMOJIS.HONOR} Honor Total`, value: `${clan.totalHonor.toLocaleString()} puntos`, inline: true },
            { name: `${EMOJIS.CALENDAR} Fundado`, value: createdDate, inline: true },
            { name: `${EMOJIS.CHART} Progreso`, value: progressToNext, inline: true },
            { name: `\u200b`, value: `\u200b`, inline: true },
            { name: `${EMOJIS.MEMBERS} Miembros del Clan`, value: membersList || 'Sin miembros', inline: false }
          )
          .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
          .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
        console.log(`${EMOJIS.CLAN_INFO} ${interaction.user.tag} consult√≥ info del clan "${clan.name}"`);
      }

      // /clan unirse
      else if (subcommand === 'unirse') {
        const clanNameInput = interaction.options.getString('nombre');
        const user = dataManager.getUser(userId, guildId);

        // Verificar si ya est√° en un clan
        if (user.clanId) {
          return interaction.reply({ content: MESSAGES.CLAN.ALREADY_IN_CLAN, flags: MessageFlags.Ephemeral });
        }

        // Buscar el clan
        const clan = dataManager.findClanByNameOrTag(guildId, clanNameInput);
        if (!clan) {
          return interaction.reply({ content: MESSAGES.CLAN.CLAN_NOT_FOUND, flags: MessageFlags.Ephemeral });
        }

        // Verificar si el clan est√° lleno
        const clanLevel = dataManager.getClanLevel(clan.totalHonor);
        if (clan.members.length >= clanLevel.maxMembers) {
          return interaction.reply({ content: MESSAGES.CLAN.CLAN_FULL(clanLevel.maxMembers), flags: MessageFlags.Ephemeral });
        }

        await interaction.deferReply();

        // A√±adir al usuario al clan
        user.clanId = clan.clanId;
        dataManager.addClanMember(clan.clanId, userId);
        dataManager.updateClanStats(clan.clanId);

        // Guardar datos
        await dataManager.saveUsers();
        await dataManager.saveClans();

        await interaction.editReply({ content: MESSAGES.CLAN.JOINED(clan.name, clan.tag) });
        console.log(`${EMOJIS.CLAN_JOIN} ${interaction.user.tag} se uni√≥ al clan "${clan.name}"`);

        // Notificar al l√≠der
        try {
          const leader = await interaction.guild.members.fetch(clan.leaderId);
          const memberDisplayName = interaction.member?.displayName || interaction.user.username;
          await leader.send(`${MESSAGES.CLAN.MEMBER_JOINED(memberDisplayName)}\n${EMOJIS.CLAN} Clan: **${clan.name}**`);
        } catch (error) {
          // Ignorar si no se puede enviar DM
        }
      }

      // /clan salir
      else if (subcommand === 'salir') {
        const user = dataManager.getUser(userId, guildId);

        // Verificar si est√° en un clan
        if (!user.clanId) {
          return interaction.reply({ content: MESSAGES.CLAN.NOT_IN_CLAN, flags: MessageFlags.Ephemeral });
        }

        const clan = dataManager.getClan(user.clanId);
        const isLeader = clan.leaderId === userId;
        const isOnlyMember = clan.members.length === 1;

        // Si es l√≠der y hay otros miembros, pedir confirmaci√≥n
        if (isLeader && !isOnlyMember) {
          const confirmButton = new ButtonBuilder()
            .setCustomId('confirm_leave_clan')
            .setLabel('Confirmar Salida')
            .setStyle(ButtonStyle.Danger);

          const cancelButton = new ButtonBuilder()
            .setCustomId('cancel_leave_clan')
            .setLabel('Cancelar')
            .setStyle(ButtonStyle.Secondary);

          const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

          await interaction.reply({
            content: MESSAGES.CLAN.CONFIRM_LEAVE_LEADER,
            components: [row],
            flags: MessageFlags.Ephemeral
          });

          // Collector para botones
          const collector = interaction.channel.createMessageComponentCollector({
            filter: (i) => i.user.id === userId,
            time: 30000
          });

          collector.on('collect', async (i) => {
            if (i.customId === 'confirm_leave_clan') {
              // Transferir liderazgo al miembro con m√°s honor
              let newLeader = null;
              let maxHonor = -1;

              for (const memberId of clan.members) {
                if (memberId === userId) continue;
                const memberUser = dataManager.getUser(memberId, guildId);
                if (memberUser.honor > maxHonor) {
                  maxHonor = memberUser.honor;
                  newLeader = memberId;
                }
              }

              if (newLeader) {
                dataManager.transferClanLeadership(clan.clanId, newLeader);
                const newLeaderMember = await interaction.guild.members.fetch(newLeader).catch(() => null);

                // Notificar al nuevo l√≠der
                try {
                  const memberDisplayName = interaction.member?.displayName || interaction.user.username;
                  await newLeaderMember.send(MESSAGES.CLAN.LEADERSHIP_TRANSFERRED(memberDisplayName));
                } catch (error) {
                  // Ignorar
                }
              }

              // Remover del clan
              user.clanId = null;
              dataManager.removeClanMember(clan.clanId, userId);
              dataManager.updateClanStats(clan.clanId);
              await dataManager.saveUsers();
              await dataManager.saveClans();

              await i.update({ content: MESSAGES.CLAN.LEFT(clan.name), components: [] });
              console.log(`${EMOJIS.CLAN_LEAVE} ${interaction.user.tag} sali√≥ del clan "${clan.name}" (liderazgo transferido)`);
            } else if (i.customId === 'cancel_leave_clan') {
              await i.update({ content: MESSAGES.GENERIC.CANCELLED, components: [] });
            }
          });

          collector.on('end', async (collected) => {
            if (collected.size === 0) {
              await interaction.editReply({ content: MESSAGES.GENERIC.TIMEOUT, components: [] });
            }
          });
        } else if (isOnlyMember) {
          // Disolver el clan
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });

          dataManager.disbandClan(clan.clanId);
          await dataManager.saveUsers();
          await dataManager.saveClans();

          await interaction.editReply({ content: MESSAGES.CLAN.DISBANDED(clan.name) });
          console.log(`${EMOJIS.WARNING} ${interaction.user.tag} disolvi√≥ el clan "${clan.name}"`);
        } else {
          // Miembro normal sale del clan
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });

          user.clanId = null;
          dataManager.removeClanMember(clan.clanId, userId);
          dataManager.updateClanStats(clan.clanId);
          await dataManager.saveUsers();
          await dataManager.saveClans();

          await interaction.editReply({ content: MESSAGES.CLAN.LEFT(clan.name) });
          console.log(`${EMOJIS.CLAN_LEAVE} ${interaction.user.tag} sali√≥ del clan "${clan.name}"`);

          // Notificar al l√≠der
          try {
            const leader = await interaction.guild.members.fetch(clan.leaderId);
            const memberDisplayName = interaction.member?.displayName || interaction.user.username;
            await leader.send(`${MESSAGES.CLAN.MEMBER_LEFT(memberDisplayName)}\n${EMOJIS.CLAN} Clan: **${clan.name}**`);
          } catch (error) {
            // Ignorar
          }
        }
      }

      // /clan miembros
      else if (subcommand === 'miembros') {
        const user = dataManager.getUser(userId, guildId);

        if (!user.clanId) {
          return interaction.reply({ content: MESSAGES.CLAN.NOT_IN_CLAN, flags: MessageFlags.Ephemeral });
        }

        await interaction.deferReply();

        const clan = dataManager.getClan(user.clanId);
        const clanLevel = dataManager.getClanLevel(clan.totalHonor);

        // Obtener todos los miembros con sus datos
        const membersData = [];
        for (const memberId of clan.members) {
          const member = await interaction.guild.members.fetch(memberId).catch(() => null);
          const memberUser = dataManager.getUser(memberId, guildId);
          const rankEmoji = EMOJIS[memberUser.rank.toUpperCase()] || EMOJIS.RONIN;
          const isLeader = memberId === clan.leaderId;

          membersData.push({
            id: memberId,
            name: member ? (member.displayName || member.user.username) : 'Usuario desconocido',
            honor: memberUser.honor,
            koku: memberUser.koku,
            rank: memberUser.rank,
            rankEmoji,
            isLeader,
            joinDate: memberUser.createdAt
          });
        }

        // Ordenar por honor (mayor a menor)
        membersData.sort((a, b) => b.honor - a.honor);

        // Crear lista de miembros
        let membersList = '';
        membersData.forEach((member, index) => {
          const leaderBadge = member.isLeader ? `${EMOJIS.LEADER} ` : '';
          const position = index + 1;
          membersList += `**${position}.** ${leaderBadge}${member.rankEmoji} ${member.name}\n`;
          membersList += `   ${EMOJIS.HONOR} ${member.honor.toLocaleString()} honor | ${EMOJIS.KOKU} ${member.koku.toLocaleString()} koku\n\n`;
        });

        const embed = new EmbedBuilder()
          .setColor(clanLevel.color)
          .setTitle(`${EMOJIS.MEMBERS} Miembros de ${clan.name} [${clan.tag}]`)
          .setDescription(`Total: **${clan.members.length}/${clanLevel.maxMembers}** miembros\n\n${membersList}`)
          .setFooter({ text: `${MESSAGES.FOOTER.DEFAULT} | Ordenado por honor` })
          .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
        console.log(`${EMOJIS.MEMBERS} ${interaction.user.tag} consult√≥ miembros del clan "${clan.name}"`);
      }

      // /clan top
      else if (subcommand === 'top') {
        await interaction.deferReply();

        const allClans = dataManager.getGuildClans(guildId);

        if (allClans.length === 0) {
          return interaction.editReply({ content: `${EMOJIS.INFO} No hay clanes en este servidor todav√≠a.` });
        }

        // Ordenar por honor total (mayor a menor)
        allClans.sort((a, b) => b.totalHonor - a.totalHonor);

        // Top 10 clanes
        const topClans = allClans.slice(0, CONSTANTS.LEADERBOARDS.TOP_DISPLAY_COUNT);
        let rankingText = '';

        for (let i = 0; i < topClans.length; i++) {
          const clan = topClans[i];
          const clanLevel = dataManager.getClanLevel(clan.totalHonor);
          const medal = i === 0 ? EMOJIS.FIRST : i === 1 ? EMOJIS.SECOND : i === 2 ? EMOJIS.THIRD : `**${i + 1}.**`;
          const leaderMember = await interaction.guild.members.fetch(clan.leaderId).catch(() => null);
          const leaderName = leaderMember ? (leaderMember.displayName || leaderMember.user.username) : 'Desconocido';

          rankingText += `${medal} **[${clan.tag}] ${clan.name}**\n`;
          rankingText += `   ${EMOJIS.CLAN_LEVEL} Nivel ${clanLevel.level} | ${EMOJIS.HONOR} ${clan.totalHonor.toLocaleString()} honor\n`;
          rankingText += `   ${EMOJIS.LEADER} ${leaderName} | ${EMOJIS.MEMBERS} ${clan.members.length}/${clanLevel.maxMembers} miembros\n\n`;
        }

        // Crear botones para cambiar tipo de ranking
        const honorButton = new ButtonBuilder()
          .setCustomId('clan_top_honor')
          .setLabel('Honor')
          .setStyle(ButtonStyle.Primary)
          .setEmoji(EMOJIS.HONOR);

        const membersButton = new ButtonBuilder()
          .setCustomId('clan_top_members')
          .setLabel('Miembros')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji(EMOJIS.MEMBERS);

        const levelButton = new ButtonBuilder()
          .setCustomId('clan_top_level')
          .setLabel('Nivel')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji(EMOJIS.CLAN_LEVEL);

        const row = new ActionRowBuilder().addComponents(honorButton, membersButton, levelButton);

        const embed = new EmbedBuilder()
          .setColor(COLORS.PRIMARY)
          .setTitle(`${EMOJIS.TROPHY} Top Clanes del Servidor`)
          .setDescription(`**Ordenado por:** ${EMOJIS.HONOR} Honor Total\n\n${rankingText}`)
          .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
          .setTimestamp();

        const response = await interaction.editReply({ embeds: [embed], components: [row] });

        // Collector para botones
        const collector = response.createMessageComponentCollector({ time: 120000 });

        collector.on('collect', async (i) => {
          if (i.user.id !== interaction.user.id) {
            const ownerDisplayName = interaction.member?.displayName || interaction.user.username;
          return i.reply({ content: `${EMOJIS.WARNING} Solo ${ownerDisplayName} puede usar estos botones.`, flags: MessageFlags.Ephemeral });
          }

          let sortedClans = [...allClans];
          let sortType = 'Honor Total';
          let sortEmoji = EMOJIS.HONOR;

          if (i.customId === 'clan_top_members') {
            sortedClans.sort((a, b) => b.members.length - a.members.length);
            sortType = 'N√∫mero de Miembros';
            sortEmoji = EMOJIS.MEMBERS;
          } else if (i.customId === 'clan_top_level') {
            sortedClans.sort((a, b) => b.level - a.level);
            sortType = 'Nivel';
            sortEmoji = EMOJIS.CLAN_LEVEL;
          } else {
            sortedClans.sort((a, b) => b.totalHonor - a.totalHonor);
          }

          const newTopClans = sortedClans.slice(0, CONSTANTS.LEADERBOARDS.TOP_DISPLAY_COUNT);
          let newRankingText = '';

          for (let idx = 0; idx < newTopClans.length; idx++) {
            const clan = newTopClans[idx];
            const clanLevel = dataManager.getClanLevel(clan.totalHonor);
            const medal = idx === 0 ? EMOJIS.FIRST : idx === 1 ? EMOJIS.SECOND : idx === 2 ? EMOJIS.THIRD : `**${idx + 1}.**`;
            const leaderMember = await interaction.guild.members.fetch(clan.leaderId).catch(() => null);
            const leaderName = leaderMember ? (leaderMember.displayName || leaderMember.user.username) : 'Desconocido';

            newRankingText += `${medal} **[${clan.tag}] ${clan.name}**\n`;
            newRankingText += `   ${EMOJIS.CLAN_LEVEL} Nivel ${clanLevel.level} | ${EMOJIS.HONOR} ${clan.totalHonor.toLocaleString()} honor\n`;
            newRankingText += `   ${EMOJIS.LEADER} ${leaderName} | ${EMOJIS.MEMBERS} ${clan.members.length}/${clanLevel.maxMembers} miembros\n\n`;
          }

          const newEmbed = new EmbedBuilder()
            .setColor(COLORS.PRIMARY)
            .setTitle(`${EMOJIS.TROPHY} Top Clanes del Servidor`)
            .setDescription(`**Ordenado por:** ${sortEmoji} ${sortType}\n\n${newRankingText}`)
            .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
            .setTimestamp();

          await i.update({ embeds: [newEmbed], components: [row] });
        });

        collector.on('end', async () => {
          try {
            const disabledRow = new ActionRowBuilder().addComponents(
              honorButton.setDisabled(true),
              membersButton.setDisabled(true),
              levelButton.setDisabled(true)
            );
            await interaction.editReply({ components: [disabledRow] });
          } catch (error) {
            // Ignorar
          }
        });

        console.log(`${EMOJIS.TROPHY} ${interaction.user.tag} consult√≥ el top de clanes`);
      }

      // /clan invitar
      else if (subcommand === 'invitar') {
        const targetUser = interaction.options.getUser('usuario');
        const user = dataManager.getUser(userId, guildId);

        // Verificar que el usuario est√© en un clan
        if (!user.clanId) {
          return interaction.reply({ content: MESSAGES.CLAN.NOT_IN_CLAN, flags: MessageFlags.Ephemeral });
        }

        const clan = dataManager.getClan(user.clanId);

        // Verificar que sea el l√≠der
        if (clan.leaderId !== userId) {
          return interaction.reply({ content: MESSAGES.CLAN.ONLY_LEADER, flags: MessageFlags.Ephemeral });
        }

        // Verificar que no sea un bot
        if (targetUser.bot) {
          return interaction.reply({ content: MESSAGES.ERRORS.INVALID_USER, flags: MessageFlags.Ephemeral });
        }

        // Verificar que el usuario invitado no est√© en otro clan
        const targetUserData = dataManager.getUser(targetUser.id, guildId);
        if (targetUserData.clanId) {
          return interaction.reply({ content: `${EMOJIS.WARNING} ${targetUser.tag} ya pertenece a otro clan.`, flags: MessageFlags.Ephemeral });
        }

        // Verificar que el clan no est√© lleno
        const clanLevel = dataManager.getClanLevel(clan.totalHonor);
        if (clan.members.length >= clanLevel.maxMembers) {
          return interaction.reply({ content: MESSAGES.CLAN.CLAN_FULL(clanLevel.maxMembers), flags: MessageFlags.Ephemeral });
        }

        // Crear botones de invitaci√≥n
        const acceptButton = new ButtonBuilder()
          .setCustomId('accept_clan_invite')
          .setLabel('Aceptar')
          .setStyle(ButtonStyle.Success)
          .setEmoji(EMOJIS.SUCCESS);

        const declineButton = new ButtonBuilder()
          .setCustomId('decline_clan_invite')
          .setLabel('Rechazar')
          .setStyle(ButtonStyle.Danger)
          .setEmoji(EMOJIS.CROSS);

        const row = new ActionRowBuilder().addComponents(acceptButton, declineButton);

        const inviteEmbed = new EmbedBuilder()
          .setColor(clanLevel.color)
          .setTitle(`${EMOJIS.CLAN_INVITE} Invitaci√≥n al Clan`)
          .setDescription(MESSAGES.CLAN.INVITATION_RECEIVED(clan.name, interaction.member?.displayName || interaction.user.username))
          .addFields(
            { name: `${EMOJIS.CLAN_TAG} Tag`, value: `[${clan.tag}]`, inline: true },
            { name: `${EMOJIS.CLAN_LEVEL} Nivel`, value: `${clanLevel.level} - ${clanLevel.name}`, inline: true },
            { name: `${EMOJIS.MEMBERS} Miembros`, value: `${clan.members.length}/${clanLevel.maxMembers}`, inline: true },
            { name: `${EMOJIS.HONOR} Honor Total`, value: `${clan.totalHonor.toLocaleString()} puntos`, inline: true }
          )
          .setFooter({ text: 'Tienes 2 minutos para responder' })
          .setTimestamp();

        await interaction.reply({ content: MESSAGES.CLAN.INVITATION_SENT(targetUser.tag), flags: MessageFlags.Ephemeral });

        // Enviar invitaci√≥n al usuario
        try {
          const inviteMessage = await targetUser.send({ embeds: [inviteEmbed], components: [row] });

          // Collector para la invitaci√≥n
          const collector = inviteMessage.createMessageComponentCollector({ time: 120000 });

          collector.on('collect', async (i) => {
            if (i.user.id !== targetUser.id) return;

            if (i.customId === 'accept_clan_invite') {
              // Verificar nuevamente que el clan no est√© lleno
              const updatedClanLevel = dataManager.getClanLevel(clan.totalHonor);
              if (clan.members.length >= updatedClanLevel.maxMembers) {
                await i.update({ content: MESSAGES.CLAN.CLAN_FULL(updatedClanLevel.maxMembers), embeds: [], components: [] });
                return;
              }

              // A√±adir al usuario al clan
              targetUserData.clanId = clan.clanId;
              dataManager.addClanMember(clan.clanId, targetUser.id);
              dataManager.updateClanStats(clan.clanId);
              await dataManager.saveUsers();
              await dataManager.saveClans();

              await i.update({
                content: MESSAGES.CLAN.JOINED(clan.name, clan.tag),
                embeds: [],
                components: []
              });

              // Notificar al l√≠der
              try {
                const leader = await interaction.guild.members.fetch(clan.leaderId);
                await leader.send(MESSAGES.CLAN.INVITATION_ACCEPTED(targetUser.tag, clan.name));
              } catch (error) {
                // Ignorar
              }

              console.log(`${EMOJIS.CLAN_JOIN} ${targetUser.tag} acept√≥ invitaci√≥n al clan "${clan.name}"`);
            } else if (i.customId === 'decline_clan_invite') {
              await i.update({
                content: MESSAGES.CLAN.INVITATION_DECLINED(clan.name),
                embeds: [],
                components: []
              });

              // Notificar al l√≠der
              try {
                const leader = await interaction.guild.members.fetch(clan.leaderId);
                await leader.send(MESSAGES.CLAN.INVITATION_DECLINED(targetUser.tag));
              } catch (error) {
                // Ignorar
              }

              console.log(`${EMOJIS.INFO} ${targetUser.tag} rechaz√≥ invitaci√≥n al clan "${clan.name}"`);
            }
          });

          collector.on('end', async (collected) => {
            if (collected.size === 0) {
              try {
                await inviteMessage.edit({
                  content: MESSAGES.CLAN.INVITATION_EXPIRED,
                  embeds: [],
                  components: []
                });
              } catch (error) {
                // Ignorar
              }
            }
          });
        } catch (error) {
          await interaction.editReply({ content: `${EMOJIS.ERROR} No pude enviar la invitaci√≥n a ${targetUser.tag}. Aseg√∫rate de que tenga los DM activados.`, flags: MessageFlags.Ephemeral });
        }
      }

      // /clan expulsar
      else if (subcommand === 'expulsar') {
        const targetUser = interaction.options.getUser('usuario');
        const user = dataManager.getUser(userId, guildId);

        // Verificar que el usuario est√© en un clan
        if (!user.clanId) {
          return interaction.reply({ content: MESSAGES.CLAN.NOT_IN_CLAN, flags: MessageFlags.Ephemeral });
        }

        const clan = dataManager.getClan(user.clanId);

        // Verificar que sea el l√≠der
        if (clan.leaderId !== userId) {
          return interaction.reply({ content: MESSAGES.CLAN.ONLY_LEADER, flags: MessageFlags.Ephemeral });
        }

        // Verificar que no se est√© expulsando a s√≠ mismo
        if (targetUser.id === userId) {
          return interaction.reply({ content: MESSAGES.CLAN.CANNOT_KICK_SELF, flags: MessageFlags.Ephemeral });
        }

        // Verificar que el usuario a expulsar est√© en el clan
        if (!clan.members.includes(targetUser.id)) {
          return interaction.reply({ content: `${EMOJIS.WARNING} ${targetUser.tag} no pertenece a tu clan.`, flags: MessageFlags.Ephemeral });
        }

        // Confirmaci√≥n
        const confirmButton = new ButtonBuilder()
          .setCustomId('confirm_kick')
          .setLabel('Confirmar Expulsi√≥n')
          .setStyle(ButtonStyle.Danger);

        const cancelButton = new ButtonBuilder()
          .setCustomId('cancel_kick')
          .setLabel('Cancelar')
          .setStyle(ButtonStyle.Secondary);

        const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

        await interaction.reply({
          content: `${EMOJIS.WARNING} ¬øEst√°s seguro de expulsar a **${targetUser.tag}** del clan?`,
          components: [row],
          flags: MessageFlags.Ephemeral
        });

        // Collector para confirmaci√≥n
        const collector = interaction.channel.createMessageComponentCollector({
          filter: (i) => i.user.id === userId,
          time: 30000
        });

        collector.on('collect', async (i) => {
          if (i.customId === 'confirm_kick') {
            // Expulsar al usuario
            const targetUserData = dataManager.getUser(targetUser.id, guildId);
            targetUserData.clanId = null;
            dataManager.removeClanMember(clan.clanId, targetUser.id);
            dataManager.updateClanStats(clan.clanId);
            await dataManager.saveUsers();
            await dataManager.saveClans();

            const targetMember = await interaction.guild.members.fetch(targetUser.id).catch(() => null);
            const targetDisplayName = targetMember?.displayName || targetUser.username;
            await i.update({ content: MESSAGES.CLAN.MEMBER_KICKED(targetDisplayName), components: [] });

            // Notificar al usuario expulsado
            try {
              await targetUser.send(MESSAGES.CLAN.YOU_WERE_KICKED(clan.name));
            } catch (error) {
              // Ignorar
            }

            console.log(`${EMOJIS.CLAN_KICK} ${interaction.user.tag} expuls√≥ a ${targetUser.tag} del clan "${clan.name}"`);
          } else if (i.customId === 'cancel_kick') {
            await i.update({ content: MESSAGES.GENERIC.CANCELLED, components: [] });
          }
        });

        collector.on('end', async (collected) => {
          if (collected.size === 0) {
            await interaction.editReply({ content: MESSAGES.GENERIC.TIMEOUT, components: [] });
          }
        });
      }
    }

    // ==================== FASE 6: CARACTER√çSTICAS INTERACTIVAS ====================

    // /duelo - Desafiar a otro usuario a un duelo
    else if (commandName === 'duelo') {
      // Verificar si el comando debe ejecutarse en un canal espec√≠fico de combate
      if (config.combatChannel && config.combatChannel.enabled && config.combatChannel.channelId) {
        if (interaction.channel.id !== config.combatChannel.channelId) {
          const combatChannel = interaction.guild.channels.cache.get(config.combatChannel.channelId);
          const channelName = combatChannel ? combatChannel.name : 'el canal de combate';
          const channelMention = combatChannel ? `<#${config.combatChannel.channelId}>` : 'el canal de combate';
          
          return interaction.reply({
            content: `‚ùå Los comandos de combate solo pueden usarse en ${channelMention} (**${channelName}**).`,
            flags: MessageFlags.Ephemeral
          });
        }
      }
      
      const opponent = interaction.options.getUser('oponente');
      const bet = interaction.options.getInteger('apuesta') || CONSTANTS.DUELS.MIN_BET;
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      // Validaciones b√°sicas
      if (opponent.id === userId) {
        return interaction.reply({ content: MESSAGES.DUEL.CANNOT_DUEL_SELF, flags: MessageFlags.Ephemeral });
      }

      if (opponent.bot) {
        return interaction.reply({ content: MESSAGES.DUEL.CANNOT_DUEL_BOT, flags: MessageFlags.Ephemeral });
      }

      // Validar apuesta
      if (bet < CONSTANTS.DUELS.MIN_BET || bet > CONSTANTS.DUELS.MAX_BET) {
        return interaction.reply({
          content: MESSAGES.DUEL.INVALID_BET(CONSTANTS.DUELS.MIN_BET, CONSTANTS.DUELS.MAX_BET),
          flags: MessageFlags.Ephemeral
        });
      }

      // Verificar cooldown
      if (dataManager.hasCooldown(userId, 'duelo')) {
        const timeLeft = dataManager.getCooldownTime(userId, 'duelo');
        return interaction.reply({ content: MESSAGES.ERRORS.COOLDOWN(timeLeft), flags: MessageFlags.Ephemeral });
      }

      // Verificar honor suficiente del retador
      const userData = dataManager.getUser(userId, guildId);
      if (userData.honor < bet) {
        return interaction.reply({ content: MESSAGES.DUEL.INSUFFICIENT_HONOR(bet), flags: MessageFlags.Ephemeral });
      }

      // Verificar honor suficiente del oponente
      const opponentData = dataManager.getUser(opponent.id, guildId);
      if (opponentData.honor < bet) {
        const opponentMember = await interaction.guild.members.fetch(opponent.id).catch(() => null);
        const opponentDisplayName = opponentMember?.displayName || opponent.username;
        return interaction.reply({ content: MESSAGES.DUEL.OPPONENT_INSUFFICIENT_HONOR(opponentDisplayName), flags: MessageFlags.Ephemeral });
      }

      // Establecer cooldown
      dataManager.setCooldown(userId, 'duelo', CONSTANTS.DUELS.COOLDOWN);

      // Crear botones de aceptar/rechazar para el oponente (mensaje p√∫blico)
      // Obtener displayNames
      const challengerDisplayName = await fetchDisplayName(interaction.guild, userId);
      const opponentDisplayName = await fetchDisplayName(interaction.guild, opponent.id);

      // Mensaje p√∫blico (sin botones, solo informativo)
      await interaction.reply({
        content: `${opponent}, ${MESSAGES.DUEL.CHALLENGE_RECEIVED(challengerDisplayName, bet)}`
      });

      // Botones para el oponente (aceptar/rechazar)
      const acceptButton = new ButtonBuilder()
        .setCustomId('accept_duel')
        .setLabel('‚öîÔ∏è Aceptar')
        .setStyle(ButtonStyle.Success);

      const declineButton = new ButtonBuilder()
        .setCustomId('decline_duel')
        .setLabel('‚ùå Rechazar')
        .setStyle(ButtonStyle.Danger);

      const opponentRow = new ActionRowBuilder().addComponents(acceptButton, declineButton);

      // Bot√≥n para el que invita (cancelar)
      const cancelButton = new ButtonBuilder()
        .setCustomId('cancel_duel')
        .setLabel('üö´ Cancelar')
        .setStyle(ButtonStyle.Secondary);

      const challengerRow = new ActionRowBuilder().addComponents(cancelButton);

      // Mensaje privado para el oponente (con botones de aceptar/rechazar)
      let opponentPrivateMessage = null;
      try {
        opponentPrivateMessage = await opponent.send({
          content: `${EMOJIS.DUEL} **${challengerDisplayName}** te ha desafiado a un duelo de honor.\n${EMOJIS.HONOR} Apuesta: **${bet} puntos de honor**\n\n${EMOJIS.KATANA} ¬øAceptas el desaf√≠o?`,
          components: [opponentRow]
        });
      } catch (error) {
        // Si no se puede enviar DM, informar en el canal p√∫blico
        await interaction.followUp({
          content: `‚ùå No se pudo enviar un mensaje privado a ${opponent}. Por favor, habilita los mensajes directos para recibir la invitaci√≥n al duelo.`,
          flags: MessageFlags.Ephemeral
        });
        return;
      }

      // Mensaje privado para el usuario que invita (con bot√≥n de cancelar)
      let challengerPrivateMessage = null;
      try {
        challengerPrivateMessage = await interaction.user.send({
          content: `${EMOJIS.DUEL} Has desafiado a **${opponentDisplayName}** a un duelo de honor.\n${EMOJIS.HONOR} Apuesta: **${bet} puntos de honor**\n\nEsperando respuesta del oponente...`,
          components: [challengerRow]
        });
      } catch (error) {
        // Si no se puede enviar DM, continuar de todas formas
        console.warn(`No se pudo enviar DM a ${interaction.user.tag} para el duelo`);
      }

      // Collectors para ambos mensajes privados
      let opponentCollector = null;
      let challengerCollector = null;

      // Collector para el oponente (aceptar/rechazar)
      if (opponentPrivateMessage) {
        opponentCollector = opponentPrivateMessage.createMessageComponentCollector({
          filter: (i) => i.user.id === opponent.id && (i.customId === 'accept_duel' || i.customId === 'decline_duel'),
          time: CONSTANTS.DUELS.INVITE_TIMEOUT * 1000
        });
      }

      // Collector para el que invita (cancelar)
      if (challengerPrivateMessage) {
        challengerCollector = challengerPrivateMessage.createMessageComponentCollector({
          filter: (i) => i.user.id === userId && i.customId === 'cancel_duel',
          time: CONSTANTS.DUELS.INVITE_TIMEOUT * 1000
        });
      }

      // Funci√≥n para limpiar collectors
      const stopAllCollectors = (reason) => {
        if (opponentCollector) opponentCollector.stop(reason);
        if (challengerCollector) challengerCollector.stop(reason);
      };

      // Manejar cancelaci√≥n del que invita
      if (challengerCollector) {
        challengerCollector.on('collect', async (i) => {
          try {
            // Obtener displayName actualizado
            const challengerDisplayNameUpdated = await fetchDisplayName(interaction.guild, userId);
            
            await i.update({
              content: `${EMOJIS.INFO} Has cancelado el duelo.`,
              components: []
            });
            
            // Actualizar mensaje p√∫blico
            await interaction.editReply({
              content: `${EMOJIS.INFO} El duelo fue cancelado por ${challengerDisplayNameUpdated}.`
            });
            
            // Actualizar mensaje privado del oponente si existe
            if (opponentPrivateMessage) {
              try {
                await opponentPrivateMessage.edit({
                  content: `${EMOJIS.INFO} El duelo fue cancelado por ${challengerDisplayNameUpdated}.`,
                  components: []
                });
              } catch (error) {
                // Ignorar si no se puede editar
              }
            }
            
            stopAllCollectors('cancelled');
          } catch (error) {
            if (error.code === 10062 || error.message?.includes('expired') || error.message?.includes('time')) {
              await i.reply({ 
                content: MESSAGES.DUEL.DUEL_EXPIRED(await fetchDisplayName(interaction.guild, opponent.id), 30), 
                flags: MessageFlags.Ephemeral 
              });
            } else {
              await i.reply({ 
                content: `‚ùå Error al procesar la cancelaci√≥n: ${error.message || 'Error desconocido'}. El duelo puede haber expirado.`, 
                flags: MessageFlags.Ephemeral 
              });
            }
          }
        });
      }

      // Manejar respuesta del oponente
      if (opponentCollector) {
        opponentCollector.on('collect', async (i) => {
          try {
            if (i.customId === 'decline_duel') {
              // Obtener displayName del oponente que rechaz√≥
              const opponentDisplayNameDeclined = await fetchDisplayName(interaction.guild, opponent.id);
              
              await i.update({ content: MESSAGES.DUEL.DUEL_DECLINED, components: [] });
              
              // Actualizar mensaje p√∫blico
              await interaction.editReply({
                content: `${EMOJIS.INFO} **${opponentDisplayNameDeclined}** ha rechazado el duelo.`
              });
              
              // Actualizar mensaje privado del que invita si existe
              if (challengerPrivateMessage) {
                try {
                  await challengerPrivateMessage.edit({
                    content: `${EMOJIS.INFO} **${opponentDisplayNameDeclined}** ha rechazado el duelo.`,
                    components: []
                  });
                } catch (error) {
                  // Ignorar si no se puede editar
                }
              }
              
              stopAllCollectors('declined');
            } else if (i.customId === 'accept_duel') {
            // Obtener displayName del oponente que acept√≥
            const opponentDisplayNameAccepted = await fetchDisplayName(interaction.guild, opponent.id);
            
            // Actualizar mensaje privado del que invita si existe
            if (challengerPrivateMessage) {
              try {
                await challengerPrivateMessage.edit({
                  content: `${EMOJIS.SUCCESS} **${opponentDisplayNameAccepted}** ha aceptado el duelo. ¬°El combate ha comenzado!`,
                  components: []
                });
              } catch (error) {
                // Ignorar si no se puede editar
              }
            }
            
            // Actualizar mensaje p√∫blico
            await interaction.editReply({
              content: `${EMOJIS.SUCCESS} **${opponentDisplayNameAccepted}** ha aceptado el duelo. ¬°El combate ha comenzado!`
            });
            
            // Duelo aceptado - crear botones de selecci√≥n de arma
            const katanaBtn = new ButtonBuilder()
              .setCustomId('weapon_katana')
              .setLabel(`${CONSTANTS.DUELS.WEAPONS.KATANA.emoji} Katana`)
              .setStyle(ButtonStyle.Primary);

            const wakizashiBtn = new ButtonBuilder()
              .setCustomId('weapon_wakizashi')
              .setLabel(`${CONSTANTS.DUELS.WEAPONS.WAKIZASHI.emoji} Wakizashi`)
              .setStyle(ButtonStyle.Primary);

            const tantoBtn = new ButtonBuilder()
              .setCustomId('weapon_tanto')
              .setLabel(`${CONSTANTS.DUELS.WEAPONS.TANTO.emoji} Tanto`)
              .setStyle(ButtonStyle.Primary);

            const weaponRow = new ActionRowBuilder().addComponents(katanaBtn, wakizashiBtn, tantoBtn);

            await i.update({
              content: `${MESSAGES.DUEL.DUEL_ACCEPTED}\n\n${MESSAGES.DUEL.WEAPON_CHOICE}`,
              components: [weaponRow]
            });

            // Almacenar las elecciones de arma
            const choices = {};

            // Esperar elecci√≥n de armas (en el mensaje privado del oponente)
            const weaponFilter = (wi) =>
              (wi.user.id === userId || wi.user.id === opponent.id) &&
              wi.customId.startsWith('weapon_');

            const weaponCollector = opponentPrivateMessage.createMessageComponentCollector({
              filter: weaponFilter,
              time: 30000,
              max: 2
            });
            
            // Tambi√©n crear collector en el mensaje privado del que invita si existe
            let challengerWeaponCollector = null;
            if (challengerPrivateMessage) {
              // Enviar botones de arma tambi√©n al que invita
              try {
                const challengerWeaponRow = new ActionRowBuilder().addComponents(
                  new ButtonBuilder()
                    .setCustomId('weapon_katana')
                    .setLabel(`${CONSTANTS.DUELS.WEAPONS.KATANA.emoji} Katana`)
                    .setStyle(ButtonStyle.Primary),
                  new ButtonBuilder()
                    .setCustomId('weapon_wakizashi')
                    .setLabel(`${CONSTANTS.DUELS.WEAPONS.WAKIZASHI.emoji} Wakizashi`)
                    .setStyle(ButtonStyle.Primary),
                  new ButtonBuilder()
                    .setCustomId('weapon_tanto')
                    .setLabel(`${CONSTANTS.DUELS.WEAPONS.TANTO.emoji} Tanto`)
                    .setStyle(ButtonStyle.Primary)
                );
                
                await challengerPrivateMessage.edit({
                  content: `${MESSAGES.DUEL.DUEL_ACCEPTED}\n\n${MESSAGES.DUEL.WEAPON_CHOICE}`,
                  components: [challengerWeaponRow]
                });
                
                challengerWeaponCollector = challengerPrivateMessage.createMessageComponentCollector({
                  filter: weaponFilter,
                  time: 30000,
                  max: 2
                });
              } catch (error) {
                // Ignorar si no se puede editar
              }
            }

            // Manejar elecciones de ambos collectors
            const handleWeaponChoice = async (wi) => {
              // Verificar si ya eligi√≥ arma
              if (choices[wi.user.id] !== undefined) {
                return wi.reply({ 
                  content: MESSAGES.DUEL.DUEL_WEAPON_ALREADY_CHOSEN, 
                  flags: MessageFlags.Ephemeral 
                });
              }
              
              const weaponId = wi.customId.replace('weapon_', '').toUpperCase();
              choices[wi.user.id] = weaponId;
              
              // Obtener datos del arma elegida
              const weaponData = CONSTANTS.DUELS.WEAPONS[weaponId];
              
              if (!weaponData) {
                console.error(`Arma no encontrada: ${weaponId}`);
                await wi.reply({ 
                  content: '‚ùå Error al procesar la elecci√≥n de arma. Por favor, intenta elegir nuevamente o inicia un nuevo duelo.', 
                  flags: MessageFlags.Ephemeral 
                });
                return;
              }
              
              // Deshabilitar todos los botones en el mensaje donde se hizo clic
              try {
                const disabledWeaponRow = new ActionRowBuilder().addComponents(
                  new ButtonBuilder()
                    .setCustomId('weapon_katana')
                    .setLabel(`${CONSTANTS.DUELS.WEAPONS.KATANA.emoji} Katana`)
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(true),
                  new ButtonBuilder()
                    .setCustomId('weapon_wakizashi')
                    .setLabel(`${CONSTANTS.DUELS.WEAPONS.WAKIZASHI.emoji} Wakizashi`)
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(true),
                  new ButtonBuilder()
                    .setCustomId('weapon_tanto')
                    .setLabel(`${CONSTANTS.DUELS.WEAPONS.TANTO.emoji} Tanto`)
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(true)
                );
                
                await wi.update({
                  content: `‚úÖ Has elegido ${weaponData.emoji} ${weaponData.name}\n\nEsperando la elecci√≥n del oponente...`,
                  components: [disabledWeaponRow]
                });
              } catch (error) {
                // Si el error es porque la interacci√≥n expir√≥
                if (error.code === 10062 || error.message?.includes('expired') || error.message?.includes('time')) {
                  return wi.reply({ 
                    content: MESSAGES.DUEL.DUEL_WEAPON_EXPIRED, 
                    flags: MessageFlags.Ephemeral 
                  });
                }
                // Si no se puede actualizar por otro motivo, solo responder
                await wi.reply({ content: `‚úÖ Has elegido ${weaponData.emoji} ${weaponData.name}`, flags: MessageFlags.Ephemeral });
              }
            };

            weaponCollector.on('collect', handleWeaponChoice);
            if (challengerWeaponCollector) {
              challengerWeaponCollector.on('collect', handleWeaponChoice);
            }

            weaponCollector.on('end', async (collected, reason) => {
              if (challengerWeaponCollector) challengerWeaponCollector.stop();
              if (Object.keys(choices).length < 2) {
                // Determinar qui√©n no eligi√≥ arma
                const challengerChose = choices[userId] !== undefined;
                const opponentChose = choices[opponent.id] !== undefined;
                let missingPlayer = '';
                
                if (!challengerChose && !opponentChose) {
                  const challengerDisplayName = await fetchDisplayName(interaction.guild, userId);
                  const opponentDisplayName = await fetchDisplayName(interaction.guild, opponent.id);
                  missingPlayer = `${challengerDisplayName} y ${opponentDisplayName}`;
                } else if (!challengerChose) {
                  missingPlayer = await fetchDisplayName(interaction.guild, userId);
                } else {
                  missingPlayer = await fetchDisplayName(interaction.guild, opponent.id);
                }
                
                await interaction.editReply({
                  content: MESSAGES.DUEL.DUEL_WEAPON_TIMEOUT(missingPlayer, 30)
                });
                return;
              }
              processDuelResult();
            });

            if (challengerWeaponCollector) {
              challengerWeaponCollector.on('end', async (collected, reason) => {
                if (Object.keys(choices).length < 2) {
                  // Determinar qui√©n no eligi√≥ arma
                  const challengerChose = choices[userId] !== undefined;
                  const opponentChose = choices[opponent.id] !== undefined;
                  let missingPlayer = '';
                  
                  if (!challengerChose && !opponentChose) {
                    const challengerDisplayName = await fetchDisplayName(interaction.guild, userId);
                    const opponentDisplayName = await fetchDisplayName(interaction.guild, opponent.id);
                    missingPlayer = `${challengerDisplayName} y ${opponentDisplayName}`;
                  } else if (!challengerChose) {
                    missingPlayer = await fetchDisplayName(interaction.guild, userId);
                  } else {
                    missingPlayer = await fetchDisplayName(interaction.guild, opponent.id);
                  }
                  
                  await interaction.editReply({
                    content: MESSAGES.DUEL.DUEL_WEAPON_TIMEOUT(missingPlayer, 30)
                  });
                  return;
                }
                processDuelResult();
              });
            }

            const processDuelResult = async () => {
              if (Object.keys(choices).length < 2) return;

            // Determinar ganador
            const challengerWeapon = choices[userId];
            const opponentWeapon = choices[opponent.id];

              const challengerWeaponData = CONSTANTS.DUELS.WEAPONS[challengerWeapon];
              const opponentWeaponData = CONSTANTS.DUELS.WEAPONS[opponentWeapon];

              // Verificar empate
              if (challengerWeapon === opponentWeapon) {
                // Obtener displayNames para el mensaje de empate
                const challengerDisplayNameForDraw = await fetchDisplayName(interaction.guild, userId);
                const opponentDisplayNameForDraw = await fetchDisplayName(interaction.guild, opponent.id);
                
                await interaction.editReply({
                  content: MESSAGES.DUEL.DUEL_DRAW(
                    challengerDisplayNameForDraw,
                    opponentDisplayNameForDraw,
                    `${challengerWeaponData.emoji} ${challengerWeaponData.name}`
                  )
                });
                
                // Mostrar resultado en mensajes privados y eliminarlos
                try {
                  if (opponentPrivateMessage) {
                    await opponentPrivateMessage.edit({
                      content: `${EMOJIS.INFO} **¬°Empate!** Ambos eligieron ${challengerWeaponData.emoji} ${challengerWeaponData.name}.\n\nNo hay ganador ni perdedor. El honor permanece intacto.`,
                      components: []
                    });
                    setTimeout(() => opponentPrivateMessage.delete().catch(() => {}), 5000);
                  }
                  if (challengerPrivateMessage) {
                    await challengerPrivateMessage.edit({
                      content: `${EMOJIS.INFO} **¬°Empate!** Ambos eligieron ${challengerWeaponData.emoji} ${challengerWeaponData.name}.\n\nNo hay ganador ni perdedor. El honor permanece intacto.`,
                      components: []
                    });
                    setTimeout(() => challengerPrivateMessage.delete().catch(() => {}), 5000);
                  }
                } catch (error) {
                  // Ignorar errores al editar/eliminar
                }
                
                return;
              }

              // Determinar ganador basado en la mec√°nica
              let winner, loser, winnerWeapon, loserWeapon;

              if (challengerWeaponData.beats === opponentWeapon) {
                winner = interaction.user;
                loser = opponent;
                winnerWeapon = `${challengerWeaponData.emoji} ${challengerWeaponData.name}`;
                loserWeapon = `${opponentWeaponData.emoji} ${opponentWeaponData.name}`;
              } else {
                winner = opponent;
                loser = interaction.user;
                winnerWeapon = `${opponentWeaponData.emoji} ${opponentWeaponData.name}`;
                loserWeapon = `${challengerWeaponData.emoji} ${challengerWeaponData.name}`;
              }

              // Actualizar honor y estad√≠sticas
              const winnerData = dataManager.getUser(winner.id, guildId);
              const loserData = dataManager.getUser(loser.id, guildId);

              dataManager.addHonor(winner.id, guildId, bet);
              dataManager.addHonor(loser.id, guildId, -bet);

              // Actualizar estad√≠sticas de duelos
              winnerData.stats.duelsWon = (winnerData.stats.duelsWon || 0) + 1;
              winnerData.stats.duelsTotal = (winnerData.stats.duelsTotal || 0) + 1;
              loserData.stats.duelsLost = (loserData.stats.duelsLost || 0) + 1;
              loserData.stats.duelsTotal = (loserData.stats.duelsTotal || 0) + 1;

              // Actualizar clanes si pertenecen a uno
              if (winnerData.clanId) dataManager.updateClanStats(winnerData.clanId);
              if (loserData.clanId) dataManager.updateClanStats(loserData.clanId);

              dataManager.dataModified.users = true;
              await dataManager.saveUsers();

              // Obtener displayNames para el mensaje de resultado
              const winnerDisplayName = await fetchDisplayName(interaction.guild, winner.id);
              const loserDisplayName = await fetchDisplayName(interaction.guild, loser.id);

              // Mensaje de resultado en el canal p√∫blico
              await interaction.editReply({
                content: MESSAGES.DUEL.DUEL_WON(winnerDisplayName, loserDisplayName, bet, winnerWeapon, loserWeapon)
              });

              // Mostrar resultado en mensajes privados y eliminarlos despu√©s
              try {
                // Mensaje para el ganador
                const winnerPrivateMessage = winner.id === userId ? challengerPrivateMessage : opponentPrivateMessage;
                if (winnerPrivateMessage) {
                  await winnerPrivateMessage.edit({
                    content: `${EMOJIS.TROPHY} **¬°VICTORIA!**\n\nHas vencido a **${loserDisplayName}** en el duelo.\n\n${winnerWeapon} vence a ${loserWeapon}\n\n${EMOJIS.HONOR} Has ganado **+${bet}** puntos de honor.`,
                    components: []
                  });
                  setTimeout(() => winnerPrivateMessage.delete().catch(() => {}), 10000);
                }
                
                // Mensaje para el perdedor
                const loserPrivateMessage = loser.id === userId ? challengerPrivateMessage : opponentPrivateMessage;
                if (loserPrivateMessage) {
                  await loserPrivateMessage.edit({
                    content: `${EMOJIS.WARNING} **DERROTA**\n\nHas sido vencido por **${winnerDisplayName}** en el duelo.\n\n${loserWeapon} es vencido por ${winnerWeapon}\n\n${EMOJIS.HONOR} Has perdido **-${bet}** puntos de honor.`,
                    components: []
                  });
                  setTimeout(() => loserPrivateMessage.delete().catch(() => {}), 10000);
                }
              } catch (error) {
                // Ignorar errores al editar/eliminar
                console.warn('Error al actualizar/eliminar mensajes privados del duelo:', error);
              }

              console.log(`${EMOJIS.DUEL} Duelo: ${winner.username} venci√≥ a ${loser.username} (${bet} honor)`);
            };
            
            stopAllCollectors('accepted');
          }
          } catch (error) {
            if (error.code === 10062 || error.message?.includes('expired') || error.message?.includes('time')) {
              await i.reply({ 
                content: MESSAGES.DUEL.DUEL_EXPIRED(await fetchDisplayName(interaction.guild, userId), 30), 
                flags: MessageFlags.Ephemeral 
              });
            } else {
              await i.reply({ 
                content: `‚ùå Error al procesar la respuesta: ${error.message || 'Error desconocido'}. El duelo puede haber expirado.`, 
                flags: MessageFlags.Ephemeral 
              });
            }
          }
        });
      }

      // Manejar expiraci√≥n de tiempo
      if (opponentCollector) {
        opponentCollector.on('end', async (collected, reason) => {
          if (reason === 'time') {
            const opponentDisplayName = await fetchDisplayName(interaction.guild, opponent.id);
            await interaction.editReply({ content: MESSAGES.DUEL.DUEL_EXPIRED(opponentDisplayName, 30) });
            // Actualizar mensaje privado del que invita si existe
            if (challengerPrivateMessage) {
              try {
                await challengerPrivateMessage.edit({
                  content: MESSAGES.DUEL.DUEL_EXPIRED(opponentDisplayName, 30),
                  components: []
                });
              } catch (error) {
                // Ignorar si no se puede editar
              }
            }
            stopAllCollectors('time');
          }
        });
      }

      if (challengerCollector) {
        challengerCollector.on('end', async (collected, reason) => {
          if (reason === 'time') {
            stopAllCollectors('time');
          }
        });
      }
    }

    // /sabiduria - Mostrar cita de sabidur√≠a samurai
    else if (commandName === 'sabiduria') {
      // Verificar si el comando debe ejecutarse en un canal espec√≠fico de combate
      if (config.combatChannel && config.combatChannel.enabled && config.combatChannel.channelId) {
        if (interaction.channel.id !== config.combatChannel.channelId) {
          const combatChannel = interaction.guild.channels.cache.get(config.combatChannel.channelId);
          const channelName = combatChannel ? combatChannel.name : 'el canal de combate';
          const channelMention = combatChannel ? `<#${config.combatChannel.channelId}>` : 'el canal de combate';
          
          return interaction.reply({
            content: `‚ùå Los comandos de combate solo pueden usarse en ${channelMention} (**${channelName}**).`,
            flags: MessageFlags.Ephemeral
          });
        }
      }
      
      const randomQuote = CONSTANTS.WISDOM_QUOTES[Math.floor(Math.random() * CONSTANTS.WISDOM_QUOTES.length)];

      const embed = new EmbedBuilder()
        .setColor(COLORS.PRIMARY)
        .setTitle(MESSAGES.WISDOM.TITLE)
        .setDescription(`*"${randomQuote.quote}"*\n\n‚Äî **${randomQuote.author}**`)
        .setFooter({ text: MESSAGES.WISDOM.FOOTER })
        .setTimestamp();

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.WISDOM} ${interaction.user.tag} consult√≥ sabidur√≠a: ${randomQuote.author}`);
    }

    // /fortuna - Consultar fortuna del d√≠a (Omikuji)
    else if (commandName === 'fortuna') {
      // Verificar si el comando debe ejecutarse en un canal espec√≠fico de combate
      if (config.combatChannel && config.combatChannel.enabled && config.combatChannel.channelId) {
        if (interaction.channel.id !== config.combatChannel.channelId) {
          const combatChannel = interaction.guild.channels.cache.get(config.combatChannel.channelId);
          const channelName = combatChannel ? combatChannel.name : 'el canal de combate';
          const channelMention = combatChannel ? `<#${config.combatChannel.channelId}>` : 'el canal de combate';
          
          return interaction.reply({
            content: `‚ùå Los comandos de combate solo pueden usarse en ${channelMention} (**${channelName}**).`,
            flags: MessageFlags.Ephemeral
          });
        }
      }
      
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;

      // Verificar cooldown (24 horas)
      if (dataManager.hasCooldown(userId, 'fortuna')) {
        const timeLeft = dataManager.getCooldownTime(userId, 'fortuna');
        const hoursLeft = Math.floor(timeLeft / 3600);
        const minutesLeft = Math.floor((timeLeft % 3600) / 60);
        const timeString = hoursLeft > 0 ? `${hoursLeft}h ${minutesLeft}m` : `${minutesLeft}m`;
        return interaction.reply({
          content: MESSAGES.FORTUNE.ALREADY_CLAIMED(timeString),
          flags: MessageFlags.Ephemeral
        });
      }

      // Generar fortuna aleatoria basada en probabilidades
      const rand = Math.random();
      let fortuneType;
      let cumulativeChance = 0;

      for (const [key, data] of Object.entries(CONSTANTS.FORTUNE.TYPES)) {
        cumulativeChance += data.chance;
        if (rand <= cumulativeChance) {
          fortuneType = key;
          break;
        }
      }

      const fortune = CONSTANTS.FORTUNE.TYPES[fortuneType];
      const userData = dataManager.getUser(userId, guildId);

      // Guardar fortuna en userData
      userData.fortune = {
        type: fortuneType,
        date: Date.now(),
        bonus: fortune.bonus
      };

      dataManager.dataModified.users = true;
      await dataManager.saveUsers();

      // Establecer cooldown de 24 horas
      dataManager.setCooldown(userId, 'fortuna', CONSTANTS.FORTUNE.COOLDOWN);

      // Determinar mensaje seg√∫n tipo de fortuna
      let fortuneMessage;
      switch (fortuneType) {
        case 'DAI_KICHI':
          fortuneMessage = MESSAGES.FORTUNE.GREAT;
          break;
        case 'KICHI':
          fortuneMessage = MESSAGES.FORTUNE.GOOD;
          break;
        case 'CHUKICHI':
          fortuneMessage = MESSAGES.FORTUNE.MEDIUM;
          break;
        case 'KYO':
          fortuneMessage = MESSAGES.FORTUNE.BAD;
          break;
      }

      const embed = new EmbedBuilder()
        .setColor(fortuneType === 'DAI_KICHI' ? '#FFB7C5' : fortuneType === 'KICHI' ? '#FFD700' : fortuneType === 'CHUKICHI' ? '#808080' : '#FF6B6B')
        .setTitle(MESSAGES.FORTUNE.TITLE)
        .setDescription(fortuneMessage)
        .setFooter({ text: MESSAGES.FORTUNE.FOOTER })
        .setTimestamp();

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.FORTUNE_GREAT} ${interaction.user.tag} consult√≥ fortuna: ${fortuneType} (${fortune.bonus > 0 ? '+' : ''}${fortune.bonus * 100}%)`);
    }

    // /perfil - Mostrar perfil completo de usuario
    else if (commandName === 'perfil') {
      // Verificar si el comando debe ejecutarse en un canal espec√≠fico de combate
      if (config.combatChannel && config.combatChannel.enabled && config.combatChannel.channelId) {
        if (interaction.channel.id !== config.combatChannel.channelId) {
          const combatChannel = interaction.guild.channels.cache.get(config.combatChannel.channelId);
          const channelName = combatChannel ? combatChannel.name : 'el canal de combate';
          const channelMention = combatChannel ? `<#${config.combatChannel.channelId}>` : 'el canal de combate';
          
          return interaction.reply({
            content: `‚ùå Los comandos de combate solo pueden usarse en ${channelMention} (**${channelName}**).`,
            flags: MessageFlags.Ephemeral
          });
        }
      }
      
      const targetUser = interaction.options.getUser('usuario') || interaction.user;
      const userId = targetUser.id;
      const guildId = interaction.guild.id;

      const userData = dataManager.getUser(userId, guildId);
      const clan = userData.clanId ? dataManager.getClan(userData.clanId) : null;

      // Informaci√≥n de fortuna
      let fortuneInfo = MESSAGES.PROFILE.NO_FORTUNE;
      if (userData.fortune && userData.fortune.type) {
        const timeSince = Date.now() - userData.fortune.date;
        const hoursAgo = Math.floor(timeSince / (1000 * 60 * 60));

        if (hoursAgo < 24) {
          const fortune = CONSTANTS.FORTUNE.TYPES[userData.fortune.type];
          fortuneInfo = `${fortune.emoji} ${fortune.name} (${userData.fortune.bonus > 0 ? '+' : ''}${userData.fortune.bonus * 100}% honor)`;
        } else {
          fortuneInfo = MESSAGES.PROFILE.NO_FORTUNE;
        }
      }

      // Obtener displayName del servidor
      const targetMember = await interaction.guild.members.fetch(targetUser.id).catch(() => null);
      const displayName = targetMember?.displayName || targetUser.username;

      const embed = new EmbedBuilder()
        .setColor(COLORS.PRIMARY)
        .setTitle(MESSAGES.PROFILE.TITLE(displayName))
        .setThumbnail(targetUser.displayAvatarURL())
        .addFields(
          {
            name: `${EMOJIS.HONOR} Honor`,
            value: `**${userData.honor}** puntos\n${getRankEmoji(userData.rank)} Rango: **${userData.rank}**`,
            inline: true
          },
          {
            name: `${EMOJIS.KOKU} Koku`,
            value: `**${userData.koku}** monedas`,
            inline: true
          },
          {
            name: `${EMOJIS.STREAK} Racha Daily`,
            value: `**${userData.dailyStreak}** d√≠as`,
            inline: true
          },
          {
            name: MESSAGES.PROFILE.STATS_TITLE,
            value: `${EMOJIS.MESSAGE} Mensajes: **${userData.stats?.messagesCount || 0}**\n${EMOJIS.VOICE} Tiempo en voz: **${userData.stats?.voiceMinutes || 0}** min\n${EMOJIS.DUEL} Duelos: **${userData.stats?.duelsWon || 0}**W / **${userData.stats?.duelsLost || 0}**L (${userData.stats?.duelsTotal || 0} total)`,
            inline: false
          },
          {
            name: MESSAGES.PROFILE.CLAN_TITLE,
            value: clan ? `üèØ **${clan.name}** [${clan.tag}]` : MESSAGES.PROFILE.NO_CLAN,
            inline: true
          },
          {
            name: MESSAGES.PROFILE.FORTUNE_TITLE,
            value: fortuneInfo,
            inline: true
          }
        )
        .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
        .setTimestamp();

      await interaction.reply({ embeds: [embed] });
      console.log(`${EMOJIS.SCROLL} ${interaction.user.tag} consult√≥ perfil de ${targetUser.tag}`);
    }

    // ==================== FASE 7: SISTEMA DE TRADUCCI√ìN ====================

    // /traducir - Traducir texto entre idiomas
    else if (commandName === 'traducir') {
      const targetLang = interaction.options.getString('idioma');
      const text = interaction.options.getString('texto');
      const userId = interaction.user.id;

      // Verificar longitud del texto
      if (text.length > CONSTANTS.TRANSLATION.MAX_LENGTH) {
        return interaction.reply({
          content: MESSAGES.TRANSLATION.TOO_LONG(CONSTANTS.TRANSLATION.MAX_LENGTH),
          flags: MessageFlags.Ephemeral
        });
      }

      // Verificar cooldown
      if (dataManager.hasCooldown(userId, 'traducir')) {
        const timeLeft = dataManager.getCooldownTime(userId, 'traducir');
        return interaction.reply({ content: MESSAGES.ERRORS.COOLDOWN(timeLeft), flags: MessageFlags.Ephemeral });
      }

      // Establecer cooldown
      dataManager.setCooldown(userId, 'traducir', CONSTANTS.TRANSLATION.COOLDOWN);

      await interaction.deferReply();

      try {
        // Importar librer√≠a de traducci√≥n
        const translateModule = require('@vitalets/google-translate-api');
        // La librer√≠a puede exportar de diferentes formas seg√∫n la versi√≥n
        const translate = translateModule.default || translateModule.translate || translateModule;

        // Mapear idioma a c√≥digo
        let targetCode;
        let targetLangName;
        let targetFlag;

        if (targetLang === 'espa√±ol') {
          targetCode = CONSTANTS.TRANSLATION.LANGUAGES.SPANISH.code;
          targetLangName = CONSTANTS.TRANSLATION.LANGUAGES.SPANISH.name;
          targetFlag = CONSTANTS.TRANSLATION.LANGUAGES.SPANISH.flag;
        } else if (targetLang === 'japon√©s') {
          targetCode = CONSTANTS.TRANSLATION.LANGUAGES.JAPANESE.code;
          targetLangName = CONSTANTS.TRANSLATION.LANGUAGES.JAPANESE.name;
          targetFlag = CONSTANTS.TRANSLATION.LANGUAGES.JAPANESE.flag;
        } else if (targetLang === 'ingl√©s') {
          targetCode = CONSTANTS.TRANSLATION.LANGUAGES.ENGLISH.code;
          targetLangName = CONSTANTS.TRANSLATION.LANGUAGES.ENGLISH.name;
          targetFlag = CONSTANTS.TRANSLATION.LANGUAGES.ENGLISH.flag;
        } else {
          return interaction.editReply(MESSAGES.TRANSLATION.INVALID_LANGUAGE);
        }

        // Traducir texto
        const result = await translate(text, { to: targetCode });

        const embed = new EmbedBuilder()
          .setColor(COLORS.PRIMARY)
          .setTitle(`${targetFlag} ${MESSAGES.TRANSLATION.TITLE('Auto-detectado', targetLangName)}`)
          .addFields(
            {
              name: `${EMOJIS.SCROLL} ${MESSAGES.TRANSLATION.ORIGINAL}`,
              value: `\`\`\`${text}\`\`\``,
              inline: false
            },
            {
              name: `${targetFlag} ${MESSAGES.TRANSLATION.TRANSLATED}`,
              value: `\`\`\`${result.text}\`\`\``,
              inline: false
            }
          )
          .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
          .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
        console.log(`${EMOJIS.GLOBE} ${interaction.user.tag} tradujo texto a ${targetLangName}`);
      } catch (error) {
        console.error('Error al traducir:', error);
        await interaction.editReply(MESSAGES.TRANSLATION.ERROR);
      }
    }

    // ==================== FASE 8: SISTEMA DE TIENDA ====================

    // /tienda - Sistema de tienda
    else if (commandName === 'tienda') {
      // Verificar si el comando debe ejecutarse en un canal espec√≠fico de tienda
      if (config.shopChannel && config.shopChannel.enabled && config.shopChannel.channelId) {
        if (interaction.channel.id !== config.shopChannel.channelId) {
          const shopChannel = interaction.guild.channels.cache.get(config.shopChannel.channelId);
          const channelName = shopChannel ? shopChannel.name : 'el canal de la tienda';
          const channelMention = shopChannel ? `<#${config.shopChannel.channelId}>` : 'el canal de la tienda';
          
          return interaction.reply({
            content: `‚ùå Los comandos de la tienda solo pueden usarse en ${channelMention} (**${channelName}**).`,
            flags: MessageFlags.Ephemeral
          });
        }
      }
      
      const subcommand = interaction.options.getSubcommand();
      const userId = interaction.user.id;
      const guildId = interaction.guild.id;
      const userData = dataManager.getUser(userId, guildId);

      // /tienda ver - Versi√≥n interactiva
      if (subcommand === 'ver') {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        // Funci√≥n helper para generar el embed de la tienda
        const generateShopEmbed = (selectedCategory = null, userDataForBalance = null) => {
          const allItems = Object.values(CONSTANTS.SHOP.ITEMS);
          const items = selectedCategory 
            ? allItems.filter(item => item.category === selectedCategory)
            : allItems;

          // Agrupar por categor√≠a
          const itemsByCategory = {
            boosts: items.filter(i => i.category === 'boosts'),
            cosmetics: items.filter(i => i.category === 'cosmetics'),
            permanent: items.filter(i => i.category === 'permanent')
          };

          let description = '';
          const categoryNames = {
            boosts: '‚ö° **BOOSTS TEMPORALES**',
            cosmetics: 'üé® **ITEMS COSM√âTICOS**',
            permanent: '‚≠ê **ITEMS PERMANENTES**'
          };

          for (const [cat, catItems] of Object.entries(itemsByCategory)) {
            if (catItems.length > 0) {
              description += `\n${categoryNames[cat]}\n`;
              for (const item of catItems) {
                const duration = item.duration 
                  ? ` (${item.duration / (60 * 60 * 1000)}h)` 
                  : '';
                description += `**${item.name}** - ${item.price.toLocaleString()} koku${duration}\n`;
                description += `   ${item.description}\n`;
              }
            }
          }

          const title = selectedCategory 
            ? `üè™ Tienda del Dojo - ${categoryNames[selectedCategory]?.replace(/\*\*/g, '') || 'Categor√≠a'}`
            : 'üè™ Tienda del Dojo';

          const balanceData = userDataForBalance || userData;
          const currentBalance = dataManager.getUser(userId, guildId).koku;

          return new EmbedBuilder()
            .setColor(COLORS.KOKU)
            .setTitle(title)
            .setDescription(description || 'No hay items disponibles.')
            .addFields({
              name: `${EMOJIS.KOKU} Tu Balance`,
              value: `**${currentBalance.toLocaleString()}** koku`,
              inline: true
            })
            .setFooter({ text: 'Selecciona un item del men√∫ para comprarlo' })
            .setTimestamp();
        };

        // Funci√≥n helper para generar el men√∫ desplegable de items
        const generateItemSelectMenu = (selectedCategory = null) => {
          const allItems = Object.values(CONSTANTS.SHOP.ITEMS);
          const items = selectedCategory 
            ? allItems.filter(item => item.category === selectedCategory)
            : allItems;

          const selectMenu = new StringSelectMenuBuilder()
            .setCustomId('shop_item_select')
            .setPlaceholder('Selecciona un item para comprar...')
            .setMinValues(1)
            .setMaxValues(1);

          // Agregar opciones (m√°ximo 25 por Discord)
          const maxOptions = Math.min(items.length, 25);
          for (let i = 0; i < maxOptions; i++) {
            const item = items[i];
            const canAfford = userData.koku >= item.price;
            const duration = item.duration 
              ? ` (${item.duration / (60 * 60 * 1000)}h)` 
              : '';
            
            // Remover emojis del nombre para el label (m√°s limpio)
            const cleanName = item.name.replace(/[‚ö°üî•üí∞‚è±Ô∏èüéÅüëëüåüüèÖü•âü•àü•áüéíüìÖ‚≠ê]/g, '').trim();
            
            const option = new StringSelectMenuOptionBuilder()
              .setLabel(cleanName || item.name) // Si se removi√≥ todo, usar el nombre original
              .setDescription(`${item.price.toLocaleString()} koku${duration} - ${item.description.substring(0, 50)}`)
              .setValue(item.id)
              .setDefault(false);
            
            // No agregar emojis al men√∫ desplegable para evitar errores de Discord
            // Los emojis ya est√°n en el nombre del item en el embed
            
            selectMenu.addOptions(option);
          }

          return selectMenu;
        };

        // Crear botones de categor√≠a
        const allButton = new ButtonBuilder()
          .setCustomId('shop_category_all')
          .setLabel('Todos')
          .setStyle(ButtonStyle.Primary)
          .setEmoji('üè™');

        const boostsButton = new ButtonBuilder()
          .setCustomId('shop_category_boosts')
          .setLabel('Boosts')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('‚ö°');

        const cosmeticsButton = new ButtonBuilder()
          .setCustomId('shop_category_cosmetics')
          .setLabel('Cosm√©ticos')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('üé®');

        const permanentButton = new ButtonBuilder()
          .setCustomId('shop_category_permanent')
          .setLabel('Permanentes')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('‚≠ê');

        const inventoryButton = new ButtonBuilder()
          .setCustomId('shop_view_inventory')
          .setLabel('Mi Inventario')
          .setStyle(ButtonStyle.Success)
          .setEmoji('üì¶');

        const closeButton = new ButtonBuilder()
          .setCustomId('shop_close')
          .setLabel('Cerrar')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('‚ùå');

        // Crear filas de componentes
        const categoryRow = new ActionRowBuilder()
          .addComponents(allButton, boostsButton, cosmeticsButton, permanentButton, inventoryButton);
        
        const closeRow = new ActionRowBuilder()
          .addComponents(closeButton);

        const selectMenuRow = new ActionRowBuilder()
          .addComponents(generateItemSelectMenu());

        // Enviar mensaje inicial (ephemeral - solo visible para el usuario)
        const initialCategory = interaction.options.getString('categoria');
        const message = await interaction.editReply({
          embeds: [generateShopEmbed(initialCategory)],
          components: [selectMenuRow, categoryRow, closeRow],
          flags: MessageFlags.Ephemeral
        });

        // Collector para botones y men√∫s
        const collector = message.createMessageComponentCollector({
          filter: (i) => i.user.id === userId,
          time: 300000 // 5 minutos
        });

        let currentCategory = initialCategory;

        collector.on('collect', async (i) => {
          try {
            // Manejar selecci√≥n de item
            if (i.isStringSelectMenu() && i.customId === 'shop_item_select') {
              const itemId = i.values[0];
              const item = Object.values(CONSTANTS.SHOP.ITEMS).find(it => it.id === itemId);

              if (!item) {
                return i.reply({ content: '‚ùå Item no encontrado.', flags: MessageFlags.Ephemeral });
              }

              // Obtener datos actualizados del usuario
              const currentUserData = dataManager.getUser(userId, guildId);

              // Verificar si puede comprar
              if (currentUserData.koku < item.price) {
                return i.reply({
                  content: `‚ùå No tienes suficiente koku. Necesitas **${item.price.toLocaleString()}** koku, pero solo tienes **${currentUserData.koku.toLocaleString()}** koku.`,
                  flags: MessageFlags.Ephemeral
                });
              }

              // Procesar compra
              currentUserData.koku -= item.price;

              if (!currentUserData.inventory) {
                currentUserData.inventory = [];
              }

              let purchaseMessage = '';

              if (item.type === 'boost') {
                if (!currentUserData.activeBoosts) {
                  currentUserData.activeBoosts = [];
                }
                const expiresAt = Date.now() + item.duration;
                currentUserData.activeBoosts.push({
                  itemId: item.id,
                  expiresAt: expiresAt,
                  effect: item.effect
                });
                purchaseMessage = `‚úÖ ¬°Compra exitosa! Has activado **${item.name}** por ${item.duration / (60 * 60 * 1000)} horas.\nüí∞ Koku restante: **${currentUserData.koku.toLocaleString()}**`;
              } else if (item.type === 'consumable') {
                const existingItem = currentUserData.inventory.find(inv => inv.itemId === item.id);
                if (existingItem) {
                  existingItem.quantity = (existingItem.quantity || 1) + 1;
                } else {
                  currentUserData.inventory.push({
                    itemId: item.id,
                    purchasedAt: Date.now(),
                    quantity: 1
                  });
                }
                purchaseMessage = `‚úÖ ¬°Compra exitosa! Has comprado **${item.name}**.\nüí∞ Koku restante: **${currentUserData.koku.toLocaleString()}**`;
              } else if (item.type === 'permanent') {
                const hasItem = currentUserData.inventory.some(inv => inv.itemId === item.id);
                if (hasItem) {
                  currentUserData.koku += item.price; // Reembolsar
                  await dataManager.saveUsers();
                  return i.reply({ content: '‚ùå Ya posees este item permanente.', flags: MessageFlags.Ephemeral });
                }
                currentUserData.inventory.push({
                  itemId: item.id,
                  purchasedAt: Date.now()
                });
                purchaseMessage = `‚úÖ ¬°Compra exitosa! Has adquirido **${item.name}** permanentemente.\nüí∞ Koku restante: **${currentUserData.koku.toLocaleString()}**`;
              }

              await dataManager.saveUsers();
              
              // Actualizar userData para el embed
              const updatedUserData = dataManager.getUser(userId, guildId);
              
              // Actualizar embed con nuevo balance
              await i.update({
                embeds: [generateShopEmbed(currentCategory, updatedUserData)],
                components: [new ActionRowBuilder().addComponents(generateItemSelectMenu(currentCategory)), categoryRow, closeRow]
              });

              // Enviar confirmaci√≥n
              await i.followUp({ content: purchaseMessage, flags: MessageFlags.Ephemeral });
              console.log(`üè™ ${interaction.user.tag} compr√≥ ${item.name} por ${item.price} koku`);
            }

            // Manejar botones de categor√≠a
            else if (i.isButton()) {
              // Bot√≥n de cerrar
              if (i.customId === 'shop_close') {
                // Deshabilitar todos los componentes
                const disabledCategoryRow = new ActionRowBuilder()
                  .addComponents(
                    allButton.setDisabled(true),
                    boostsButton.setDisabled(true),
                    cosmeticsButton.setDisabled(true),
                    permanentButton.setDisabled(true),
                    inventoryButton.setDisabled(true)
                  );

                const disabledSelectRow = new ActionRowBuilder()
                  .addComponents(generateItemSelectMenu(currentCategory).setDisabled(true));

                const disabledCloseRow = new ActionRowBuilder()
                  .addComponents(closeButton.setDisabled(true));

                await i.update({
                  embeds: [generateShopEmbed(currentCategory)],
                  components: [disabledSelectRow, disabledCategoryRow, disabledCloseRow]
                });
                
                collector.stop('closed');
                return;
              }
              
              if (i.customId === 'shop_view_inventory') {
                // Mostrar inventario
                if (!userData.inventory || userData.inventory.length === 0) {
                  return i.reply({ content: 'üì¶ Tu inventario est√° vac√≠o.', flags: MessageFlags.Ephemeral });
                }

                let description = '';
                const activeBoosts = userData.activeBoosts || [];
                
                if (activeBoosts.length > 0) {
                  description += '**‚ö° BOOSTS ACTIVOS:**\n';
                  for (const boost of activeBoosts) {
                    const item = Object.values(CONSTANTS.SHOP.ITEMS).find(it => it.id === boost.itemId);
                    if (item) {
                      const timeLeft = Math.max(0, boost.expiresAt - Date.now());
                      const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                      const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
                      description += `${item.name} - ${hoursLeft}h ${minutesLeft}m restantes\n`;
                    }
                  }
                  description += '\n';
                }

                description += '**üì¶ ITEMS EN INVENTARIO:**\n';
                const groupedItems = {};
                for (const invItem of userData.inventory) {
                  const item = Object.values(CONSTANTS.SHOP.ITEMS).find(it => it.id === invItem.itemId);
                  if (item) {
                    if (!groupedItems[item.id]) {
                      groupedItems[item.id] = { item, quantity: 0 };
                    }
                    groupedItems[item.id].quantity += (invItem.quantity || 1);
                  }
                }

                for (const { item, quantity } of Object.values(groupedItems)) {
                  description += `${item.name}${quantity > 1 ? ` x${quantity}` : ''}\n`;
                }

                const inventoryEmbed = new EmbedBuilder()
                  .setColor(COLORS.PRIMARY)
                  .setTitle('üì¶ Tu Inventario')
                  .setDescription(description || 'No tienes items.')
                  .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
                  .setTimestamp();

                return i.reply({ embeds: [inventoryEmbed], flags: MessageFlags.Ephemeral });
              }

              // Cambiar categor√≠a
              let newCategory = null;
              if (i.customId === 'shop_category_all') {
                newCategory = null;
              } else if (i.customId === 'shop_category_boosts') {
                newCategory = 'boosts';
              } else if (i.customId === 'shop_category_cosmetics') {
                newCategory = 'cosmetics';
              } else if (i.customId === 'shop_category_permanent') {
                newCategory = 'permanent';
              }

              currentCategory = newCategory;

              // Actualizar botones (marcar el seleccionado)
              const updatedAllButton = new ButtonBuilder()
                .setCustomId('shop_category_all')
                .setLabel('Todos')
                .setStyle(newCategory === null ? ButtonStyle.Primary : ButtonStyle.Secondary)
                .setEmoji('üè™');

              const updatedBoostsButton = new ButtonBuilder()
                .setCustomId('shop_category_boosts')
                .setLabel('Boosts')
                .setStyle(newCategory === 'boosts' ? ButtonStyle.Primary : ButtonStyle.Secondary)
                .setEmoji('‚ö°');

              const updatedCosmeticsButton = new ButtonBuilder()
                .setCustomId('shop_category_cosmetics')
                .setLabel('Cosm√©ticos')
                .setStyle(newCategory === 'cosmetics' ? ButtonStyle.Primary : ButtonStyle.Secondary)
                .setEmoji('üé®');

              const updatedPermanentButton = new ButtonBuilder()
                .setCustomId('shop_category_permanent')
                .setLabel('Permanentes')
                .setStyle(newCategory === 'permanent' ? ButtonStyle.Primary : ButtonStyle.Secondary)
                .setEmoji('‚≠ê');

              const updatedCategoryRow = new ActionRowBuilder()
                .addComponents(updatedAllButton, updatedBoostsButton, updatedCosmeticsButton, updatedPermanentButton, inventoryButton);

              // Obtener datos actualizados del usuario
              const updatedUserDataForCategory = dataManager.getUser(userId, guildId);
              
              await i.update({
                embeds: [generateShopEmbed(newCategory, updatedUserDataForCategory)],
                components: [new ActionRowBuilder().addComponents(generateItemSelectMenu(newCategory)), updatedCategoryRow, closeRow]
              });
            }
          } catch (error) {
            console.error('Error en collector de tienda:', error);
            
            // Determinar el tipo de error
            let errorMessage = '‚ùå Ocurri√≥ un error. Por favor intenta de nuevo.';
            
            if (error.code === 10062 || error.message?.includes('expired') || error.message?.includes('time')) {
              errorMessage = MESSAGES.GENERIC.INTERACTION_EXPIRED;
            } else if (error.message?.includes('disabled') || error.message?.includes('not available')) {
              errorMessage = MESSAGES.GENERIC.BUTTON_DISABLED;
            } else if (error.message) {
              errorMessage = `‚ùå Error: ${error.message}. Por favor, intenta de nuevo o usa \`/tienda ver\` para abrir la tienda nuevamente.`;
            }
            
            if (i.deferred || i.replied) {
              await i.followUp({ content: errorMessage, flags: MessageFlags.Ephemeral });
            } else {
              await i.reply({ content: errorMessage, flags: MessageFlags.Ephemeral });
            }
          }
        });

        collector.on('end', () => {
          // Deshabilitar componentes cuando expire o se cierre
          const disabledCategoryRow = new ActionRowBuilder()
            .addComponents(
              allButton.setDisabled(true),
              boostsButton.setDisabled(true),
              cosmeticsButton.setDisabled(true),
              permanentButton.setDisabled(true),
              inventoryButton.setDisabled(true)
            );

          const disabledSelectRow = new ActionRowBuilder()
            .addComponents(generateItemSelectMenu(currentCategory).setDisabled(true));

          const disabledCloseRow = new ActionRowBuilder()
            .addComponents(closeButton.setDisabled(true));

          message.edit({ components: [disabledSelectRow, disabledCategoryRow, disabledCloseRow] }).catch(() => {});
        });

        console.log(`üè™ ${interaction.user.tag} consult√≥ la tienda`);
      }

      // /tienda comprar
      else if (subcommand === 'comprar') {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        const itemId = interaction.options.getString('item');
        const item = Object.values(CONSTANTS.SHOP.ITEMS).find(i => i.id === itemId);

        if (!item) {
          return interaction.editReply(`‚ùå Item \`${itemId}\` no encontrado. Usa \`/tienda ver\` para ver los items disponibles.`);
        }

        if (userData.koku < item.price) {
          return interaction.editReply(
            `‚ùå No tienes suficiente koku. Necesitas **${item.price.toLocaleString()}** koku, pero solo tienes **${userData.koku.toLocaleString()}** koku.`
          );
        }

        // Inicializar inventario si no existe
        if (!userData.inventory) {
          userData.inventory = [];
        }

        // Procesar la compra seg√∫n el tipo de item
        userData.koku -= item.price;

        if (item.type === 'boost') {
          // Agregar boost activo
          if (!userData.activeBoosts) {
            userData.activeBoosts = [];
          }
          const expiresAt = Date.now() + item.duration;
          userData.activeBoosts.push({
            itemId: item.id,
            expiresAt: expiresAt,
            effect: item.effect
          });
          await dataManager.saveUsers();
          await interaction.editReply(
            `‚úÖ ¬°Compra exitosa! Has activado **${item.name}** por ${item.duration / (60 * 60 * 1000)} horas.\n` +
            `üí∞ Koku restante: **${userData.koku.toLocaleString()}**`
          );
        } else if (item.type === 'consumable') {
          // Agregar al inventario
          userData.inventory.push({
            itemId: item.id,
            purchasedAt: Date.now(),
            quantity: (userData.inventory.find(i => i.itemId === item.id)?.quantity || 0) + 1
          });
          await dataManager.saveUsers();
          await interaction.editReply(
            `‚úÖ ¬°Compra exitosa! Has comprado **${item.name}**.\n` +
            `üí∞ Koku restante: **${userData.koku.toLocaleString()}**\n` +
            `üì¶ Usa \`/tienda inventario\` para ver tus items.`
          );
        } else if (item.type === 'permanent') {
          // Verificar si ya lo tiene
          const hasItem = userData.inventory.some(i => i.itemId === item.id);
          if (hasItem) {
            userData.koku += item.price; // Reembolsar
            await dataManager.saveUsers();
            return interaction.editReply(`‚ùå Ya posees este item permanente.`);
          }
          userData.inventory.push({
            itemId: item.id,
            purchasedAt: Date.now()
          });
          await dataManager.saveUsers();
          await interaction.editReply(
            `‚úÖ ¬°Compra exitosa! Has adquirido **${item.name}** permanentemente.\n` +
            `üí∞ Koku restante: **${userData.koku.toLocaleString()}**`
          );
        }

        console.log(`üè™ ${interaction.user.tag} compr√≥ ${item.name} por ${item.price} koku`);
      }

      // /tienda inventario
      else if (subcommand === 'inventario') {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        if (!userData.inventory || userData.inventory.length === 0) {
          return interaction.editReply('üì¶ Tu inventario est√° vac√≠o. Usa `/tienda ver` para ver los items disponibles.');
        }

        let description = '';
        const activeBoosts = userData.activeBoosts || [];
        
        if (activeBoosts.length > 0) {
          description += '**‚ö° BOOSTS ACTIVOS:**\n';
          for (const boost of activeBoosts) {
            const item = Object.values(CONSTANTS.SHOP.ITEMS).find(i => i.id === boost.itemId);
            if (item) {
              const timeLeft = Math.max(0, boost.expiresAt - Date.now());
              const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
              const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
              description += `${item.name} - ${hoursLeft}h ${minutesLeft}m restantes\n`;
            }
          }
          description += '\n';
        }

        description += '**üì¶ ITEMS EN INVENTARIO:**\n';
        const groupedItems = {};
        for (const invItem of userData.inventory) {
          const item = Object.values(CONSTANTS.SHOP.ITEMS).find(i => i.id === invItem.itemId);
          if (item) {
            if (!groupedItems[item.id]) {
              groupedItems[item.id] = { item, quantity: 0 };
            }
            groupedItems[item.id].quantity += (invItem.quantity || 1);
          }
        }

        for (const { item, quantity } of Object.values(groupedItems)) {
          description += `${item.name}${quantity > 1 ? ` x${quantity}` : ''}\n`;
        }

        const embed = new EmbedBuilder()
          .setColor(COLORS.PRIMARY)
          .setTitle('üì¶ Tu Inventario')
          .setDescription(description || 'No tienes items.')
          .setFooter({ text: MESSAGES.FOOTER.DEFAULT })
          .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
        console.log(`üè™ ${interaction.user.tag} consult√≥ su inventario`);
      }
    }

    // ==================== SISTEMA DE M√öSICA (DOJO DEL SONIDO) ====================

    // Reproducci√≥n b√°sica
    else if (commandName === 'tocar' || commandName === 'play') {
      await musicHandlers.handlePlay(interaction);
    }
    else if (commandName === 'pausar' || commandName === 'pause') {
      await musicHandlers.handlePause(interaction);
    }
    else if (commandName === 'reanudar' || commandName === 'resume') {
      await musicHandlers.handleResume(interaction);
    }
    else if (commandName === 'siguiente' || commandName === 'skip') {
      await musicHandlers.handleSkip(interaction);
    }
    else if (commandName === 'detener' || commandName === 'stop') {
      await musicHandlers.handleStop(interaction);
    }
    // Gesti√≥n de cola
    else if (commandName === 'cola' || commandName === 'queue') {
      await musicHandlers.handleQueue(interaction);
    }
    else if (commandName === 'ahora' || commandName === 'sonando' || commandName === 'nowplaying' || commandName === 'np') {
      await musicHandlers.handleNowPlaying(interaction);
    }
    else if (commandName === 'limpiar' || commandName === 'clear') {
      await musicHandlers.handleClear(interaction);
    }
    else if (commandName === 'saltar' || commandName === 'jump') {
      await musicHandlers.handleJump(interaction);
    }
    else if (commandName === 'remover' || commandName === 'remove') {
      await musicHandlers.handleRemove(interaction);
    }
    // Control y opciones
    else if (commandName === 'volumen' || commandName === 'volume') {
      await musicHandlers.handleVolume(interaction);
    }
    else if (commandName === 'buscar' || commandName === 'search') {
      await musicHandlers.handleSearch(interaction);
    }
    else if (commandName === 'mezclar' || commandName === 'shuffle') {
      await musicHandlers.handleShuffle(interaction);
    }
    else if (commandName === 'repetir' || commandName === 'loop') {
      await musicHandlers.handleLoop(interaction);
    }

    // Comando no reconocido
    else {
      console.warn(`‚ö†Ô∏è Comando no reconocido: ${commandName} (usado por ${interaction.user.tag})`);
      await interaction.reply({
        content: `‚ùå Comando \`/${commandName}\` no reconocido. Usa \`/help\` para ver todos los comandos disponibles.`,
        flags: MessageFlags.Ephemeral
      });
    }

  } catch (error) {
    console.error(`Error ejecutando comando slash ${commandName}:`, error);
    const errorMessage = '‚ùå Ocurri√≥ un error al ejecutar este comando. Por favor intenta de nuevo m√°s tarde.';

    if (interaction.deferred || interaction.replied) {
      await interaction.editReply(errorMessage);
    } else {
      await interaction.reply({ content: errorMessage, flags: MessageFlags.Ephemeral });
    }
  }
});

// Manejo de errores
client.on(Events.Error, (error) => {
  console.error('Error del cliente de Discord:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('Rechazo de promesa no manejado:', error);
});

// ==================== GRACEFUL SHUTDOWN ====================
// Guarda todos los datos antes de cerrar el bot
async function gracefulShutdown(signal) {
  console.log(`\n${EMOJIS.WARNING} Se√±al ${signal} recibida. Iniciando cierre graceful...`);

  try {
    // Guardar todos los datos
    await dataManager.shutdown();

    // Destruir el cliente de Discord
    client.destroy();
    console.log(`${EMOJIS.SUCCESS} Bot desconectado correctamente`);

    console.log(`${EMOJIS.FLAG} Cierre completado. Que el c√≥digo Bushido te proteja, guerrero.\n`);
    process.exit(0);
  } catch (error) {
    console.error(`${EMOJIS.ERROR} Error durante cierre graceful:`, error);
    process.exit(1);
  }
}

// Capturar se√±ales de cierre
process.on('SIGINT', () => gracefulShutdown('SIGINT'));   // Ctrl+C
process.on('SIGTERM', () => gracefulShutdown('SIGTERM')); // Kill command

// Iniciar sesi√≥n en Discord
client.login(process.env.DISCORD_TOKEN).catch((error) => {
  console.error('Fall√≥ el inicio de sesi√≥n:', error);
  console.error('\n‚ö†Ô∏è  SOLUCI√ìN: Aseg√∫rate de haber habilitado los "Privileged Gateway Intents" en el Discord Developer Portal');
  console.error('Instrucciones: https://discord.com/developers/applications ‚Üí Tu Bot ‚Üí Bot ‚Üí Privileged Gateway Intents');
  console.error('Habilita: SERVER MEMBERS INTENT y MESSAGE CONTENT INTENT\n');
  process.exit(1);
});
